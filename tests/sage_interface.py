from typing import Any, Protocol

import numpy as np
from numpy.typing import NDArray

type TVector = NDArray[np.floating[Any] | np.integer[Any]]
type TMatrix = NDArray[np.floating[Any] | np.integer[Any]]
type TSquareMatrix = NDArray[np.floating[Any] | np.integer[Any]]

type TVectorFloat = NDArray[np.floating[Any]]
type TMatrixFloat = NDArray[np.floating[Any]]
type TSquareMatrixFloat = NDArray[np.floating[Any]]

type TVectorInt = NDArray[np.integer[Any]]
type TMatrixInt = NDArray[np.integer[Any]]
type TSquareMatrixInt = NDArray[np.integer[Any]]

DEFAULT_PORT = 5050
DEFAULT_AUTHKEY = b"sage"

# https://doc.sagemath.org/html/en/reference/modules/sage/modules/free_module_integer.html
# https://doc.sagemath.org/html/en/reference/cryptography/sage/crypto/lattice.html
# https://doc.sagemath.org/html/en/reference/matrices/sage/matrix/matrix_integer_dense.html#sage.matrix.matrix_integer_dense.Matrix_integer_dense.echelon_form
# https://doc.sagemath.org/html/en/reference/matrices/sage/matrix/matrix2.html#sage.matrix.matrix2.Matrix.gram_schmidt


class SageEngineInterface(Protocol):
    def gen_lattice(self, type: str, n: int, m: int, q: int, seed: int | None, quotient: TVector | None, dual: bool) -> TMatrixInt: ...

    def lll(self, lattice_basis: TMatrixInt, delta: float, transformation: bool) -> TMatrixInt | tuple[TMatrixInt, TMatrixInt]: ...

    def bkz(self, lattice_basis: TMatrixInt, delta: float, block_size: int) -> TMatrixInt: ...

    def hkz(self, lattice_basis: TMatrixInt) -> TMatrixInt: ...

    def shortest_vector(self, lattice_basis: TMatrixInt) -> TVectorInt: ...

    def closest_vector(self, lattice_basis: TMatrixInt, target_vector: TVector) -> TVectorInt: ...

    def babai(self, algorithm: str, lattice_basis: TMatrixInt, target_vector: TVector, delta: float) -> TVectorInt: ...

    def discriminant(self, lattice_basis: TMatrixInt) -> int: ...

    def gaussian_heuristic(self, lattice_basis: TMatrixInt) -> float: ...

    def hadamard_ratio(self, lattice_basis: TMatrixInt) -> float: ...

    def is_unimodular(self, lattice_basis: TMatrixInt) -> bool: ...

    def volume(self, lattice_basis: TMatrixInt) -> float: ...

    def hnf(self, matrix: TMatrixInt, transformation: bool) -> TMatrixInt | tuple[TMatrixInt, TMatrixInt]: ...

    def is_lll_reduced(self, lattice_basis: TMatrixInt, delta: float) -> bool: ...

    def gso(self, matrix: TMatrix, orthonormal: bool) -> tuple[TMatrix, TMatrix]: ...

    def left_kernel(self, matrix: TMatrixInt) -> TMatrixInt: ...

    def left_nullity(self, matrix: TMatrixInt) -> int: ...

    def right_kernel(self, matrix: TMatrixInt) -> TMatrixInt: ...

    def right_nullity(self, matrix: TMatrixInt) -> int: ...

    def rank(self, matrix: TMatrixInt) -> int: ...
