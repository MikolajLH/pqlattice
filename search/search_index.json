{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pqlattice","text":""},{"location":"#installation","title":"Installation","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python: 3.12 or higher</li> </ul>"},{"location":"#installing-the-library","title":"Installing the Library","text":"<p><code>pqlattice</code> is available on PyPI</p> pipuv <pre><code>pip install pqlattice\n</code></pre> <pre><code>uv add pqlattice\n</code></pre>"},{"location":"#quick-example","title":"Quick Example","text":"<p><pre><code>import pqlattice as pq\n\nB = pq.random.randlattice(20, seed=0)\npq.show(B, max_rows=4, max_cols = 6)\n</code></pre> <pre><code>Matrix of integers with shape: 20 x 20\n======================================\n          [0]      [1]      [2]  ...      [17]      [18]      [19]\n [0]        0   744754   864912  ...   -518094  -1059265  -2020217\n [1]        0  4468524  5208149  ...  15148796   7154090   -905760\n ...      ...      ...      ...  ...       ...       ...       ...\n[18]  1485231  1016267  -566813  ...   6150781   7321489   6305462\n[19]        0  -744754  -864912  ...  -1587933   -306240   1026485\n</code></pre> <pre><code>print(pq.lattice.hadamard_ratio(B)) # 0.014816328763771074\nmin_v = (min(pq.linalg.norm(v) for v in B))\nprint(min_v) # 2569945.025682845\n\nL = pq.lattice.lll(B)\nprint(pq.linalg.norm(L[0])) # 87588.95332175172\nprint(pq.lattice.hadamard_ratio(L)) # 0.8653657544560275\n\nsv = pq.lattice.shortest_vector(L)\nprint(pq.linalg.norm(sv)) # 87588.95332175172\n\nH = pq.lattice.hkz(L)\nprint(pq.lattice.hadamard_ratio(H)) # 0.8661175966425156\n</code></pre></p>"},{"location":"api/","title":"API Reference","text":"Namespace Description pqlattice main module, exposes all other submodules integer basic integer functions and modular arithmetic operations lattice lattice reductions, embeddings and and general lattice functions linalg linear algebra functions for integer matrices and modular integer matrices polynomial implemenation of polynomial ring and polynomial quotient ring random random samples i.a. discrete gaussian, uniform and LWE typing declaration of type aliases for matrices and vectors"},{"location":"api/integer/","title":"Integer module","text":""},{"location":"api/integer/#miscellaneous-integer-functions","title":"Miscellaneous integer functions","text":""},{"location":"api/integer/#pqlattice.integer.eea","title":"pqlattice.integer.eea","text":"<pre><code>eea(a: int, b: int) -&gt; tuple[int, int, int]\n</code></pre><pre><code>eea(a: Array, b: int) -&gt; tuple[Array, Array, Array]\n</code></pre> <pre><code>eea(\n    a: int | Array, b: int\n) -&gt; tuple[int, int, int] | tuple[Array, Array, Array]\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <code>b</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>tuple[int, int, int] | tuple[Array, Array, Array]</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.is_prime","title":"pqlattice.integer.is_prime","text":"<pre><code>is_prime(p: int) -&gt; bool\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>bool</code> <p>description</p>"},{"location":"api/integer/#modintring-class-for-modular-arithmetic-operations","title":"<code>ModIntRing</code> class for modular arithmetic operations","text":""},{"location":"api/integer/#pqlattice.integer.ModIntRing","title":"pqlattice.integer.ModIntRing","text":"<pre><code>ModIntRing(modulus: int)\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>modulus</code> <code>int</code> <p>description</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.q","title":"q  <code>property</code>","text":"<pre><code>q: int\n</code></pre> <p>summary</p> <p>Returns:</p> Type Description <code>_type_</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.add","title":"add","text":"<pre><code>add(a: int, b: int) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description</p> required <code>b</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.cmodl","title":"cmodl","text":"<pre><code>cmodl(a: int) -&gt; int\n</code></pre><pre><code>cmodl(a: Array) -&gt; Array\n</code></pre> <pre><code>cmodl(a: int | Array) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.cmodr","title":"cmodr","text":"<pre><code>cmodr(a: int) -&gt; int\n</code></pre><pre><code>cmodr(a: Array) -&gt; Array\n</code></pre> <pre><code>cmodr(a: int | Array) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.div","title":"div","text":"<pre><code>div(a: int, b: int) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description</p> required <code>b</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.inv","title":"inv","text":"<pre><code>inv(a: int) -&gt; int\n</code></pre><pre><code>inv(a: Array) -&gt; Array\n</code></pre> <pre><code>inv(a: int | Array) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.is_zero","title":"is_zero","text":"<pre><code>is_zero(a: int) -&gt; bool\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>bool</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.mod","title":"mod","text":"<pre><code>mod(a: int) -&gt; int\n</code></pre><pre><code>mod(a: Array) -&gt; Array\n</code></pre> <pre><code>mod(a: int | Array) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.mul","title":"mul","text":"<pre><code>mul(a: int, b: int) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description</p> required <code>b</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.neg","title":"neg","text":"<pre><code>neg(a: int) -&gt; int\n</code></pre><pre><code>neg(a: Array) -&gt; Array\n</code></pre> <pre><code>neg(a: int | Array) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.pow","title":"pow","text":"<pre><code>pow(a: int, r: int) -&gt; int\n</code></pre><pre><code>pow(a: Array, r: int) -&gt; Array\n</code></pre> <pre><code>pow(a: int | Array, r: int) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <code>r</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.ModIntRing.sub","title":"sub","text":"<pre><code>sub(a: int, b: int) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int</code> <p>description</p> required <code>b</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/integer/#free-functions-for-modular-arithmetic-operations","title":"Free functions for modular arithmetic operations","text":""},{"location":"api/integer/#pqlattice.integer.mod","title":"pqlattice.integer.mod","text":"<pre><code>mod(a: int, modulus: int) -&gt; int\n</code></pre><pre><code>mod(a: Array, modulus: int) -&gt; Array\n</code></pre> <pre><code>mod(a: int | Array, modulus: int) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.cmodl","title":"pqlattice.integer.cmodl","text":"<pre><code>cmodl(a: int, modulus: int) -&gt; int\n</code></pre><pre><code>cmodl(a: Array, modulus: int) -&gt; Array\n</code></pre> <pre><code>cmodl(a: int | Array, modulus: int) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.cmodr","title":"pqlattice.integer.cmodr","text":"<pre><code>cmodr(a: int, modulus: int) -&gt; int\n</code></pre><pre><code>cmodr(a: Array, modulus: int) -&gt; Array\n</code></pre> <pre><code>cmodr(a: int | Array, modulus: int) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.modinv","title":"pqlattice.integer.modinv","text":"<pre><code>modinv(a: int, modulus: int) -&gt; int\n</code></pre><pre><code>modinv(a: Array, modulus: int) -&gt; Array\n</code></pre> <pre><code>modinv(a: int | Array, modulus: int) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p> <code>ValueError</code> <p>description</p>"},{"location":"api/integer/#pqlattice.integer.modpow","title":"pqlattice.integer.modpow","text":"<pre><code>modpow(a: Array, r: int, modulus: int) -&gt; Array\n</code></pre><pre><code>modpow(a: int, r: int, modulus: int) -&gt; int\n</code></pre> <pre><code>modpow(a: int | Array, r: int, modulus: int) -&gt; int | Array\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>int | Array</code> <p>description</p> required <code>r</code> <code>int</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int | Array</code> <p>description</p>"},{"location":"api/lattice/","title":"Lattice module","text":""},{"location":"api/lattice/#general-lattice-functions","title":"General lattice functions","text":""},{"location":"api/lattice/#pqlattice.lattice.volume","title":"pqlattice.lattice.volume","text":"<pre><code>volume(lattice_basis: SquareMatrix) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.rank","title":"pqlattice.lattice.rank","text":"<pre><code>rank(lattice_basis: SquareMatrix) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.hadamard_ratio","title":"pqlattice.lattice.hadamard_ratio","text":"<pre><code>hadamard_ratio(lattice_basis: SquareMatrix) -&gt; float\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>float</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.discriminant","title":"pqlattice.lattice.discriminant","text":"<pre><code>discriminant(lattice_basis: SquareMatrix) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.gaussian_heuristic","title":"pqlattice.lattice.gaussian_heuristic","text":"<pre><code>gaussian_heuristic(lattice_basis: SquareMatrix) -&gt; float\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>float</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.is_lll_reduced","title":"pqlattice.lattice.is_lll_reduced","text":"<pre><code>is_lll_reduced(\n    lattice_basis: SquareMatrix, delta: float = 0.99\n) -&gt; bool\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <code>delta</code> <code>float</code> <p>description, by default 0.99</p> <code>0.99</code> <p>Returns:</p> Type Description <code>bool</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.is_size_reduced","title":"pqlattice.lattice.is_size_reduced","text":"<pre><code>is_size_reduced(lattice_basis: SquareMatrix) -&gt; bool\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>bool</code> <p>description</p>"},{"location":"api/lattice/#lattice-reduction-algorithms","title":"Lattice reduction algorithms","text":""},{"location":"api/lattice/#pqlattice.lattice.gso","title":"pqlattice.lattice.gso","text":"<pre><code>gso(B: Matrix) -&gt; tuple[Matrix, SquareMatrix]\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>B</code> <code>Matrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>tuple[Matrix, SquareMatrix]</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.lll","title":"pqlattice.lattice.lll","text":"<pre><code>lll(\n    lattice_basis: SquareMatrix, delta: float = 0.99\n) -&gt; SquareMatrix\n</code></pre>"},{"location":"api/lattice/#pqlattice.lattice.bkz","title":"pqlattice.lattice.bkz","text":"<pre><code>bkz(\n    lattice_basis: SquareMatrix,\n    block_size: int = 10,\n    delta: float = 0.99,\n) -&gt; SquareMatrix\n</code></pre>"},{"location":"api/lattice/#pqlattice.lattice.hkz","title":"pqlattice.lattice.hkz","text":"<pre><code>hkz(\n    lattice_basis: SquareMatrix, delta: float = 0.99\n) -&gt; SquareMatrix\n</code></pre>"},{"location":"api/lattice/#pqlattice.lattice.glr_2dim","title":"pqlattice.lattice.glr_2dim","text":"<pre><code>glr_2dim(lattice_basis: SquareMatrix) -&gt; SquareMatrix\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p>"},{"location":"api/lattice/#svp-and-cvp","title":"SVP and CVP","text":""},{"location":"api/lattice/#pqlattice.lattice.shortest_vector","title":"pqlattice.lattice.shortest_vector","text":"<pre><code>shortest_vector(lattice_basis: SquareMatrix) -&gt; Vector\n</code></pre>"},{"location":"api/lattice/#pqlattice.lattice.babai_closest_vector","title":"pqlattice.lattice.babai_closest_vector","text":"<pre><code>babai_closest_vector(\n    lattice_basis: SquareMatrix, target_vector: Vector\n) -&gt; Vector\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <code>target_vector</code> <code>Vector</code> <p>description</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.babai_nearest_plane","title":"pqlattice.lattice.babai_nearest_plane","text":"<pre><code>babai_nearest_plane(\n    lattice_basis: SquareMatrix, target_vector: Vector\n) -&gt; Vector\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>lattice_basis</code> <code>SquareMatrix</code> <p>description</p> required <code>target_vector</code> <code>Vector</code> <p>description</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>description</p>"},{"location":"api/lattice/#lattice-embeddings","title":"Lattice embeddings","text":""},{"location":"api/lattice/#pqlattice.lattice.embeddings.sis_basis","title":"pqlattice.lattice.embeddings.sis_basis","text":"<pre><code>sis_basis(A: Matrix, q: int) -&gt; SquareMatrix\n</code></pre> <p>lattice: L = { x | Ax = 0 mod q }</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>q</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.embeddings.lwe_basis","title":"pqlattice.lattice.embeddings.lwe_basis","text":"<pre><code>lwe_basis(A: Matrix, q: int) -&gt; SquareMatrix\n</code></pre> <p>lattice: L = { y | y = xA mod q }</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>q</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.embeddings.kannan","title":"pqlattice.lattice.embeddings.kannan","text":"<pre><code>kannan(A: Matrix, b: Vector, q: int) -&gt; SquareMatrix\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>b</code> <code>Vector</code> <p>description</p> required <code>q</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.embeddings.bai_galbraith","title":"pqlattice.lattice.embeddings.bai_galbraith","text":"<pre><code>bai_galbraith(\n    A: Matrix, b: Vector, q: int, M: int\n) -&gt; SquareMatrix\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>b</code> <code>Vector</code> <p>description</p> required <code>q</code> <code>int</code> <p>description</p> required <code>M</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.embeddings.subset_sum","title":"pqlattice.lattice.embeddings.subset_sum","text":"<pre><code>subset_sum(sequence: Vector, S: int) -&gt; SquareMatrix\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>sequence</code> <code>Vector</code> <p>description</p> required <code>S</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p>"},{"location":"api/lattice/#pqlattice.lattice.embeddings.ntru","title":"pqlattice.lattice.embeddings.ntru","text":"<pre><code>ntru(quotient: Vector, q: int, h: Vector) -&gt; SquareMatrix\n</code></pre> <p>construct the ntru lattice basis</p> <p>Parameters:</p> Name Type Description Default <code>quotient</code> <code>Vector</code> <p>description</p> required <code>q</code> <code>int</code> <p>description</p> required <code>h</code> <code>Vector</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p>"},{"location":"api/linalg/","title":"Linalg module","text":""},{"location":"api/linalg/#norm-and-squared-norm","title":"Norm and squared norm","text":""},{"location":"api/linalg/#pqlattice.linalg.norm","title":"pqlattice.linalg.norm","text":"<pre><code>norm(v: Vector) -&gt; float\n</code></pre> <p>computes the square root of the dot product of the vector with itself.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>float</code>"},{"location":"api/linalg/#pqlattice.linalg.norm2","title":"pqlattice.linalg.norm2","text":"<pre><code>norm2(v: Vector) -&gt; int\n</code></pre> <p>computes the squared norm of a given vector, that is the dot product of vector with itself</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>int</code>"},{"location":"api/linalg/#pqlattice.linalg.per_row_norm","title":"pqlattice.linalg.per_row_norm","text":"<pre><code>per_row_norm(A: Matrix) -&gt; list[float]\n</code></pre> <p>Computes the list of norms of rows of a given matrix.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> required <p>Returns:</p> Type Description <code>list[float]</code>"},{"location":"api/linalg/#pqlattice.linalg.per_row_norm2","title":"pqlattice.linalg.per_row_norm2","text":"<pre><code>per_row_norm2(A: Matrix) -&gt; list[int]\n</code></pre> <p>Computes the list of squared norms of rows of a given matrix.</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> required <p>Returns:</p> Type Description <code>list[int]</code>"},{"location":"api/linalg/#helper-functions-for-in-place-matrix-operations","title":"Helper functions for in place matrix operations","text":""},{"location":"api/linalg/#pqlattice.linalg.row_add","title":"pqlattice.linalg.row_add","text":"<pre><code>row_add(m: Matrix, i: int, k: int, s: int) -&gt; None\n</code></pre> <p>utility function for <code>in place</code> row add operation</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Matrix</code> required <code>i</code> <code>int</code> <p>target row</p> required <code>k</code> <code>int</code> <p>source row</p> required <code>s</code> <code>int</code> <p>scaling factor</p> required"},{"location":"api/linalg/#pqlattice.linalg.row_scale","title":"pqlattice.linalg.row_scale","text":"<pre><code>row_scale(m: Matrix, i: int, s: int) -&gt; None\n</code></pre> <p>utility function for <code>in place</code> row scale operation</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Matrix</code> required <code>i</code> <code>int</code> required <code>s</code> <code>int</code> <p>scaling factor</p> required"},{"location":"api/linalg/#pqlattice.linalg.row_swap","title":"pqlattice.linalg.row_swap","text":"<pre><code>row_swap(m: Matrix, i: int, k: int) -&gt; None\n</code></pre> <p>utility function for <code>in place</code> row swap operation</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Matrix</code> required <code>i</code> <code>int</code> required <code>k</code> <code>int</code> required"},{"location":"api/linalg/#pqlattice.linalg.col_add","title":"pqlattice.linalg.col_add","text":"<pre><code>col_add(m: Matrix, i: int, k: int, s: int) -&gt; None\n</code></pre> <p>utility function for <code>in place</code> column add operation</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Matrix</code> required <code>i</code> <code>int</code> <p>target column</p> required <code>k</code> <code>int</code> <p>source column</p> required <code>s</code> <code>int</code> <p>scaling factor</p> required"},{"location":"api/linalg/#pqlattice.linalg.col_scale","title":"pqlattice.linalg.col_scale","text":"<pre><code>col_scale(m: Matrix, i: int, s: int) -&gt; None\n</code></pre> <p>utility function for <code>in place</code> column scale operation</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Matrix</code> required <code>i</code> <code>int</code> required <code>s</code> <code>int</code> <p>scaling factor</p> required"},{"location":"api/linalg/#pqlattice.linalg.col_swap","title":"pqlattice.linalg.col_swap","text":"<pre><code>col_swap(m: Matrix, i: int, k: int) -&gt; None\n</code></pre> <p>utility function for <code>in place</code> column swap operation</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>Matrix</code> required <code>i</code> <code>int</code> required <code>k</code> <code>int</code> required"},{"location":"api/linalg/#functions-for-integral-matrices","title":"Functions for integral matrices","text":""},{"location":"api/linalg/#pqlattice.linalg.hnf","title":"pqlattice.linalg.hnf","text":"<pre><code>hnf(matrix: SquareMatrix) -&gt; tuple[Matrix, SquareMatrix]\n</code></pre>"},{"location":"api/linalg/#pqlattice.linalg.det","title":"pqlattice.linalg.det","text":"<pre><code>det(A: SquareMatrix) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.left_kernel","title":"pqlattice.linalg.left_kernel","text":"<pre><code>left_kernel(A: Matrix)\n</code></pre> <p>{x : xA = 0}</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>_type_</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.right_kernel","title":"pqlattice.linalg.right_kernel","text":"<pre><code>right_kernel(A: Matrix) -&gt; Matrix\n</code></pre> <p>{x : Ax = 0}</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.left_nullity","title":"pqlattice.linalg.left_nullity","text":"<pre><code>left_nullity(a: Matrix) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Matrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.right_nullity","title":"pqlattice.linalg.right_nullity","text":"<pre><code>right_nullity(a: Matrix) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Matrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.rank","title":"pqlattice.linalg.rank","text":"<pre><code>rank(a: Matrix) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Matrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.minor","title":"pqlattice.linalg.minor","text":"<pre><code>minor(A: SquareMatrix, i: int, j: int) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>SquareMatrix</code> <p>description</p> required <code>i</code> <code>int</code> <p>description</p> required <code>j</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.cofactor","title":"pqlattice.linalg.cofactor","text":"<pre><code>cofactor(A: SquareMatrix, i: int, j: int) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>SquareMatrix</code> <p>description</p> required <code>i</code> <code>int</code> <p>description</p> required <code>j</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.cofactor_matrix","title":"pqlattice.linalg.cofactor_matrix","text":"<pre><code>cofactor_matrix(A: SquareMatrix) -&gt; SquareMatrix\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>SquareMatrix</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p>"},{"location":"api/linalg/#functions-for-matrices-with-coefficients-from-z_q","title":"Functions for matrices with coefficients from \\(Z_q\\)","text":""},{"location":"api/linalg/#pqlattice.linalg.mod_ref","title":"pqlattice.linalg.mod_ref","text":"<pre><code>mod_ref(\n    A: Matrix, modulus: int\n) -&gt; tuple[Matrix, SquareMatrix]\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>tuple[Matrix, SquareMatrix]</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.mod_rref","title":"pqlattice.linalg.mod_rref","text":"<pre><code>mod_rref(\n    A: Matrix, modulus: int\n) -&gt; tuple[Matrix, SquareMatrix]\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>tuple[Matrix, SquareMatrix]</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.mod_matinv","title":"pqlattice.linalg.mod_matinv","text":"<pre><code>mod_matinv(A: SquareMatrix, modulus: int) -&gt; SquareMatrix\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>SquareMatrix</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.mod_right_kernel","title":"pqlattice.linalg.mod_right_kernel","text":"<pre><code>mod_right_kernel(A: Matrix, modulus: int) -&gt; Matrix\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.mod_left_kernel","title":"pqlattice.linalg.mod_left_kernel","text":"<pre><code>mod_left_kernel(A: Matrix, modulus: int) -&gt; Matrix\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>Matrix</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.mod_left_nullity","title":"pqlattice.linalg.mod_left_nullity","text":"<pre><code>mod_left_nullity(A: Matrix, modulus: int) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/linalg/#pqlattice.linalg.mod_right_nullity","title":"pqlattice.linalg.mod_right_nullity","text":"<pre><code>mod_right_nullity(A: Matrix, modulus: int) -&gt; int\n</code></pre> <p>summary</p> <p>Parameters:</p> Name Type Description Default <code>A</code> <code>Matrix</code> <p>description</p> required <code>modulus</code> <code>int</code> <p>description</p> required <p>Returns:</p> Type Description <code>int</code> <p>description</p>"},{"location":"api/polynomial/","title":"Polynomial module","text":""},{"location":"api/polynomial/#class-for-integer-polynomial-ring","title":"Class for integer polynomial ring","text":""},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing","title":"pqlattice.polynomial.ModIntPolyRing","text":"<pre><code>ModIntPolyRing(modulus: int)\n</code></pre> <p>Construct the polynomial ring over coefficients from integer quotient ring with given modulus.</p> <p>Parameters:</p> Name Type Description Default <code>modulus</code> <code>int</code> <p>integer quotient ring modulus</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the modulus is less than 2</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.add","title":"add","text":"<pre><code>add(polynomial_a: Vector, polynomial_b: Vector) -&gt; Vector\n</code></pre> <p>Adds two polynomials</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.coprime","title":"coprime","text":"<pre><code>coprime(polynomial_a: Vector, polynomial_b: Vector) -&gt; bool\n</code></pre> <p>Checks if two polynomials are coprime, that is if their <code>gcd == 1</code></p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>bool</code> <p>True if coprime, False otherwise</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.deg","title":"deg","text":"<pre><code>deg(polynomial: Vector) -&gt; int\n</code></pre> <p>Returns degree of the given polynomial</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>int</code> <p>degree</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.eea","title":"eea","text":"<pre><code>eea(\n    polynomial_a: Vector, polynomial_b: Vector\n) -&gt; tuple[Vector, Vector, Vector]\n</code></pre> <p>Extended Euclidean algorithm for the polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>tuple[Vector, Vector, Vector]</code> <p><code>tuple[s, t, gcd]</code> such that <code>polynomial_a * s + polynomial_b * t == gcd</code></p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.euclidean_div","title":"euclidean_div","text":"<pre><code>euclidean_div(\n    polynomial_a: Vector, polynomial_b: Vector\n) -&gt; tuple[Vector, Vector]\n</code></pre> <p>Performs the euclidean division for the polynomials</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>tuple[Vector, Vector]</code> <p><code>tuple[q, r]</code> such that <code>polynomial_a == q * polynomial_b + r</code></p> <p>Raises:</p> Type Description <code>ZeroDivisionError</code> <p>If the <code>polynomial_b</code> is the zero polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.gcd","title":"gcd","text":"<pre><code>gcd(polynomial_a: Vector, polynomial_b: Vector) -&gt; Vector\n</code></pre> <p>Computes the polynomial that is the greates common divisor of the given polynomials</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.is_zero","title":"is_zero","text":"<pre><code>is_zero(polynomial: Vector) -&gt; bool\n</code></pre> <p>Checks if the polynomial is the zero polynomial in the ring.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>bool</code> <p>True if it is zero polynomial, False otherwise</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.mul","title":"mul","text":"<pre><code>mul(polynomial_a: Vector, polynomial_b: Vector) -&gt; Vector\n</code></pre> <p>multiplies two polynomials</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.reduce","title":"reduce","text":"<pre><code>reduce(polynomial: Vector) -&gt; Vector\n</code></pre> <p>Reduces the polynomials coefficients according to the ring, that is modulo <code>self.modulus</code></p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial with coefficients from range <code>[0, self.modulus)</code></p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.rem","title":"rem","text":"<pre><code>rem(polynomial_a: Vector, polynomial_b: Vector) -&gt; Vector\n</code></pre> <p>Returns remainder of the euclidean division</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.sub","title":"sub","text":"<pre><code>sub(polynomial_a: Vector, polynomial_b: Vector) -&gt; Vector\n</code></pre> <p>Subtract one polynomial from the other</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyRing.to_monic","title":"to_monic","text":"<pre><code>to_monic(polynomial: Vector) -&gt; Vector\n</code></pre> <p>Transformt the given polynomial to its monic form, that is multiplies the polynomial by the modular inverse of the leading coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial with leading coefficient equal to one.</p>"},{"location":"api/polynomial/#class-for-integer-polynomial-quotient-ring","title":"Class for integer polynomial quotient ring","text":""},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyQuotientRing","title":"pqlattice.polynomial.ModIntPolyQuotientRing","text":"<pre><code>ModIntPolyQuotientRing(\n    poly_modulus: Vector, int_modulus: int\n)\n</code></pre> <p>Creates the polynomial quotient ring of coefficient from the integer quotien ring</p> <p>Parameters:</p> Name Type Description Default <code>poly_modulus</code> <code>Vector</code> <p>modulus of the polynomial quotient ring</p> required <code>int_modulus</code> <code>int</code> <p>modulus of the integer quotient ring</p> required"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyQuotientRing.quotient","title":"quotient  <code>property</code>","text":"<pre><code>quotient: Vector\n</code></pre> <p>Get the polynomial modulus of this ring.</p> <p>Returns:</p> Type Description <code>Vector</code> <p><code>p</code> the polynomial modulus of this quotient ring</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyQuotientRing.add","title":"add","text":"<pre><code>add(polynomial_a: Vector, polynomial_b: Vector) -&gt; Vector\n</code></pre> <p>adds two polynomials</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyQuotientRing.center_lift","title":"center_lift","text":"<pre><code>center_lift(polynomial: Vector) -&gt; Vector\n</code></pre> <p>Hoffstein page. 414 - 415</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyQuotientRing.inv","title":"inv","text":"<pre><code>inv(polynomial: Vector) -&gt; Vector\n</code></pre> <p>Tries to find the multiplicative inverse of the given polynomial in the ring.</p> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the inverse does not exists</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyQuotientRing.mul","title":"mul","text":"<pre><code>mul(polynomial_a: Vector, polynomial_b: Vector) -&gt; Vector\n</code></pre> <p>multiplies two polynomials</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyQuotientRing.reduce","title":"reduce","text":"<pre><code>reduce(polynomial: Vector) -&gt; Vector\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>polynomial</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.ModIntPolyQuotientRing.sub","title":"sub","text":"<pre><code>sub(polynomial_a: Vector, polynomial_b: Vector) -&gt; Vector\n</code></pre> <p>subtract one polynomial from the other</p> <p>Parameters:</p> Name Type Description Default <code>polynomial_a</code> <code>Vector</code> required <code>polynomial_b</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#general-free-functions-for-polynomial-operations","title":"General free functions for polynomial operations","text":""},{"location":"api/polynomial/#pqlattice.polynomial.poly","title":"pqlattice.polynomial.poly","text":""},{"location":"api/polynomial/#pqlattice.polynomial.poly.add","title":"add","text":"<pre><code>add(p: Vector, q: Vector) -&gt; Vector\n</code></pre> <p>Adds two polynomials together.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Vector</code> required <code>q</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.deg","title":"deg","text":"<pre><code>deg(p: Vector) -&gt; int\n</code></pre> <p>Returns degree of the given polynomial. Assumes -1 for the zero polynomial.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>int</code> <p>degree</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the vector is empty</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.is_zero_poly","title":"is_zero_poly","text":"<pre><code>is_zero_poly(p: Vector) -&gt; bool\n</code></pre> <p>Checks if the poly is zero poly - all coefficients are equal to zero.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Vector</code> <p>polynomial</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if all coefficients are equal to zero, False otherwise</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the given Vector is empty</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.make_poly","title":"make_poly","text":"<pre><code>make_poly(data: ArrayLike) -&gt; Vector\n</code></pre> <p>Helper function, creates polynomial from the array like.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ArrayLike</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the data has wrong shape</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.monomial","title":"monomial","text":"<pre><code>monomial(coeff: int, degree: int) -&gt; Vector\n</code></pre> <p>For given degree <code>d</code> and coefficient <code>c</code>, constructs a monomial <code>cX + ** (d - 1)</code></p> <p>Parameters:</p> Name Type Description Default <code>coeff</code> <code>int</code> required <code>degree</code> <code>int</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if degree is negative</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.mul","title":"mul","text":"<pre><code>mul(p: Vector, q: Vector) -&gt; Vector\n</code></pre> <p>Multiplies two polynomials.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Vector</code> required <code>q</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.pad","title":"pad","text":"<pre><code>pad(p: Vector, max_deg: int) -&gt; Vector\n</code></pre> <p>Pad's polynomial's coefficient's array with zero entries for powers higher than polynomial's degree, so that length of resulting array is equal to max_deg + 1.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Vector</code> required <code>max_deg</code> <code>int</code> <p>Degree that <code>p</code> is to be expanded to</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If max deg is less than the degree of the given polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.sub","title":"sub","text":"<pre><code>sub(p: Vector, q: Vector) -&gt; Vector\n</code></pre> <p>Subtract one polynomial from the other</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Vector</code> required <code>q</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.trim","title":"trim","text":"<pre><code>trim(p: Vector) -&gt; Vector\n</code></pre> <p>Trims zero coefficients of powers higher than polynomial's degree, so that resulting coefficient's arrray has length of <code>deg(p) + 1</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>Vector</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>polynomial</p>"},{"location":"api/polynomial/#pqlattice.polynomial.poly.zero_poly","title":"zero_poly","text":"<pre><code>zero_poly(max_deg: int = 0) -&gt; Vector\n</code></pre> <p>constructs zero polynomial, expanded to the given parameter max_deg</p> <p>Parameters:</p> Name Type Description Default <code>max_deg</code> <code>int</code> <p>by default 0</p> <code>0</code> <p>Returns:</p> Type Description <code>Vector</code> <p>Vector of length <code>max_deg + 1</code> filled with zeros</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the <code>max_deg</code> is negative</p>"},{"location":"api/pqlattice/","title":"pqlattice - main namespace","text":""},{"location":"api/pqlattice/#helper-conversion-functions","title":"Helper conversion functions","text":""},{"location":"api/pqlattice/#pqlattice.as_integer","title":"pqlattice.as_integer","text":"<pre><code>as_integer(obj: ArrayLike) -&gt; Array\n</code></pre> <p>Helper function that converts given obj to numpy's array of python's ints allowing arbitrary large elements</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>ArrayLike</code> <p>object to be converted to numpy's array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>numpy's array with dtype=object and elements converted to int</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pqlattice as pq\n&gt;&gt;&gt; pq.as_integer([3**100, 2**100, 5**50])\narray([515377520732011331036461129765621272702107522001,\n   1267650600228229401496703205376,\n   88817841970012523233890533447265625], dtype=object)\n</code></pre>"},{"location":"api/pqlattice/#pqlattice.as_rational","title":"pqlattice.as_rational","text":"<pre><code>as_rational(obj: ArrayLike) -&gt; Array\n</code></pre> <p>Helper function that converts given obj to numpy's array of python's fractions.Fraction allowing arbitrary big rational elements</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>ArrayLike</code> <p>object to be converted to numpy's array</p> required <p>Returns:</p> Type Description <code>Array</code> <p>numpy's array with dtype=object and elements converted to fractions.Fraction</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pqlattice as pq\n&gt;&gt;&gt; pq.as_rational([3**100, 2**100, 5**50])\narray([Fraction(515377520732011331036461129765621272702107522001, 1),\n   Fraction(1267650600228229401496703205376, 1),\n   Fraction(88817841970012523233890533447265625, 1)], dtype=object)\n</code></pre>"},{"location":"api/pqlattice/#pqshow-helper-printing-function","title":"<code>pq.show</code> - Helper printing function","text":""},{"location":"api/pqlattice/#pqlattice.show","title":"pqlattice.show","text":"<pre><code>show(\n    a: Array,\n    max_rows: int = 10,\n    max_cols: int = 10,\n    val_width: int = 15,\n)\n</code></pre> <p>Helper function that prints the numpy's array in a human redable format</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>Array</code> <p>The array to print</p> required <code>max_rows</code> <code>int</code> <p>Max number of rows to display before truncating, by default 10</p> <code>10</code> <code>max_cols</code> <code>int</code> <p>Max number of columns to display before truncating, by default 10</p> <code>10</code> <code>val_width</code> <code>int</code> <p>Max characters per cell, by default 15. If a string representation of element is longer, it is truncated e.g 1234...5678</p> <code>15</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pqlattice as pq\n&gt;&gt;&gt; M = pq.random.distribution.Uniform(0, 2**50, seed=0).sample_matrix(7, 5)\n&gt;&gt;&gt; pq.show(M)\nMatrix of integers with shape: 7 x 5\n====================================\n                [0]              [1]              [2]              [3]              [4]\n[0]  867496826243021   91162487198805  109421..4040930  806253307773444  491889324856851\n[1]  313616384600182  314680579360371  213540430176889  330931104930059  222394738660569\n[2]  166055160201467  743539086037546  796665326308852  712012953150114  460445890320316\n[3]  996855368208390  140240390954947  210028256050344  750154124310314  141827853726696\n[4]  499232256057935  320872572303314  205400145011268  110177..2031755  678794279728913\n[5]  655478801553847  281048514639229  749289460799082  457570956347073  647748016542327\n[6]  206336435080453  713924001980837  545175556185458  414036094290124   74247901643189\n</code></pre>"},{"location":"api/pqlattice/#miscellaneous-helper-functions","title":"Miscellaneous helper functions","text":""},{"location":"api/pqlattice/#pqlattice.to_bits","title":"pqlattice.to_bits","text":"<pre><code>to_bits(data: bytes) -&gt; list[int]\n</code></pre> <p>Converts the byte array to list of bits</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> required <p>Returns:</p> Type Description <code>list[int]</code> <p>list of bits that when packed represents the given data</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pqlattice as pq\n&gt;&gt;&gt; f\"{ord('a'):08b}\"\n'01100001'\n&gt;&gt;&gt; f\"{ord('Z'):08b}\"\n'01011010'\n&gt;&gt;&gt; pq.to_bits(b\"aZ\")  # ascii\n[0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0]\n</code></pre>"},{"location":"api/pqlattice/#pqlattice.from_bits","title":"pqlattice.from_bits","text":"<pre><code>from_bits(bits: Sequence[int]) -&gt; bytes\n</code></pre> <p>Converts the sequencs of bits to bytes, inverse of <code>pqlattice.to_bits</code></p> <p>Parameters:</p> Name Type Description Default <code>bits</code> <code>Sequence[int]</code> required <p>Returns:</p> Type Description <code>bytes</code> <p>bytes representing bits packed in chunks of 8</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>description</p>"},{"location":"api/pqlattice/#pqlattice.pad_data","title":"pqlattice.pad_data","text":"<pre><code>pad_data(data: Vector, block_size: int) -&gt; Vector\n</code></pre> <p>pads the vector of bits to a given block size. marks the end of a block data by putting pattern \\10+\\ at the end.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Vector</code> <p>data of bits with length strictly less than block size</p> required <code>block_size</code> <code>int</code> required <p>Returns:</p> Type Description <code>Vector</code> <p>vector with lenght equal to block_size</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the data does not meet length constraint</p>"},{"location":"api/pqlattice/#pqlattice.unpad_data","title":"pqlattice.unpad_data","text":"<pre><code>unpad_data(padded_data: Vector) -&gt; Vector\n</code></pre> <p>unpads the data, inverse of <code>pqlattice.pad_data</code></p> <p>Parameters:</p> Name Type Description Default <code>padded_data</code> <code>Vector</code> <p>data with a \\10+\\ pattern at the end</p> required <p>Returns:</p> Type Description <code>Vector</code> <p>data with the padding pattern removed</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>if the given data does not match the expected pattern</p>"},{"location":"api/random/","title":"Random module","text":""},{"location":"api/random/#distributions","title":"Distributions","text":""},{"location":"api/random/#pqlattice.random.distribution.Uniform","title":"pqlattice.random.distribution.Uniform","text":"<pre><code>Uniform(\n    range_beg: int, range_end: int, seed: int | None = None\n)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>Creates a uniform sampler from range [range_beg; range_end].</p> <p>Parameters:</p> Name Type Description Default <code>range_beg</code> <code>int</code> <p>begin of sampling range. Inclusive</p> required <code>range_end</code> <code>int</code> <p>end of sampling range. Inclusive</p> required <code>seed</code> <code>int | None</code> <p>seed for random number generator, by default None</p> <code>None</code>"},{"location":"api/random/#pqlattice.random.distribution.Uniform.get_params","title":"get_params","text":"<pre><code>get_params() -&gt; dict[str, int]\n</code></pre> <p>returns dictionary of parameters of the distribution</p> <p>Returns:</p> Type Description <code>dict[str, int]</code> <p>dict <code>d = {\"range_beg\": self._range_beg, \"range_end\": self._range_end}</code></p>"},{"location":"api/random/#pqlattice.random.distribution.Uniform.sample_int","title":"sample_int","text":"<pre><code>sample_int(seed: int | None = None) -&gt; int\n</code></pre> <p>Get uniform random int from range <code>[self.beg_range, self.end_range]</code></p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>set the new seed, if None does nothing, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>random integer from range [self.beg_range, self.end_range]</p>"},{"location":"api/random/#pqlattice.random.distribution.Uniform.sample_matrix","title":"sample_matrix","text":"<pre><code>sample_matrix(\n    rows: int,\n    cols: int | None = None,\n    seed: int | None = None,\n) -&gt; Matrix\n</code></pre> <p>Get a matrix of random uniform ints. Each element of the matrix is sampled from range <code>[self.beg_range, self.end_range]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>number of rows</p> required <code>cols</code> <code>int | None</code> <p>number of cols, if None equal to number of rows , by default None</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>set the new seed, if None does nothing, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Matrix</code> <p>matrix <code>m</code> with shape <code>(rows, cols)</code> and random elements from range <code>[self.beg_range, self.end_range]</code></p>"},{"location":"api/random/#pqlattice.random.distribution.Uniform.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(n: int, seed: int | None = None) -&gt; Vector\n</code></pre> <p>Get a vector of random uniform ints. Each element of the vector is sampled from range <code>[self.beg_range, self.end_range]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>dimension of the vector</p> required <code>seed</code> <code>int | None</code> <p>set the new seed, if None does nothing, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Vector</code> <p>vector <code>v</code> with shape <code>(n,)</code> and random elements from range <code>[self.beg_range, self.end_range]</code></p>"},{"location":"api/random/#pqlattice.random.distribution.Uniform.set_params","title":"set_params","text":"<pre><code>set_params(\n    range_beg: int | None = None,\n    range_end: int | None = None,\n) -&gt; None\n</code></pre> <p>Set the parameters of the distribution</p> <p>Parameters:</p> Name Type Description Default <code>range_beg</code> <code>int | None</code> <p>if None does nothing, by default None</p> <code>None</code> <code>range_end</code> <code>int | None</code> <p>if None does nothing, by default None</p> <code>None</code>"},{"location":"api/random/#pqlattice.random.distribution.DiscreteGaussian","title":"pqlattice.random.distribution.DiscreteGaussian","text":"<pre><code>DiscreteGaussian(\n    sigma: float,\n    center: int | float = 0,\n    tail_cut: float = 6.0,\n    seed: int | None = None,\n)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>Creates DiscreteGaussian sampler that uses rejection sampling method. Samples <code>x</code> are accepted with probability `exp(-((x - center) ** 2) / (2 * sigma ** 2)).</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>float</code> <p>standard deviation of the distribution</p> required <code>center</code> <code>int | float</code> <p>mean of the distribution, by default 0</p> <code>0</code> <code>tail_cut</code> <code>float</code> <p>samples outside the range <code>[center - sigma * tail_cut, center + sigma * tail_cut]</code> are considered to have probability zero, by default 6.0</p> <code>6.0</code> <code>seed</code> <code>int | None</code> <p>seed for random number generator, by default None</p> <code>None</code>"},{"location":"api/random/#pqlattice.random.distribution.DiscreteGaussian.get_params","title":"get_params","text":"<pre><code>get_params() -&gt; dict[str, float]\n</code></pre> <p>returns dictionary of parameters of the distribution</p> <p>Returns:</p> Type Description <code>dict[str, float]</code> <p>dict <code>d = {\"sigma\": self.sigma, \"center\": self.center, \"tail_cut\": self.tail_cut, \"bound\": self.bound}</code></p>"},{"location":"api/random/#pqlattice.random.distribution.DiscreteGaussian.sample_int","title":"sample_int","text":"<pre><code>sample_int(seed: int | None = None) -&gt; int\n</code></pre> <p>Get random int according to the gaussian probability.</p> <p>Parameters:</p> Name Type Description Default <code>seed</code> <code>int | None</code> <p>set the new seed, if None does nothing, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>random integer sampled from discrete gaussian distribution</p>"},{"location":"api/random/#pqlattice.random.distribution.DiscreteGaussian.sample_matrix","title":"sample_matrix","text":"<pre><code>sample_matrix(\n    rows: int,\n    cols: int | None = None,\n    seed: int | None = None,\n) -&gt; Matrix\n</code></pre> <p>Get a matrix of integers sampled from discrete gaussian distribution.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>int</code> <p>number of rows</p> required <code>cols</code> <code>int | None</code> <p>number of cols, if None equal to number of rows , by default None</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>set the new seed, if None does nothing, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Matrix</code> <p>matrix <code>m</code> with shape <code>(rows, cols)</code> and random elements from discrete gaussian distribution.</p>"},{"location":"api/random/#pqlattice.random.distribution.DiscreteGaussian.sample_vector","title":"sample_vector","text":"<pre><code>sample_vector(n: int, seed: int | None = None) -&gt; Vector\n</code></pre> <p>Get a vector of integers sampled from discrete gaussian distribution.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>dimension of the vector</p> required <code>seed</code> <code>int | None</code> <p>set the new seed, if None does nothing, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>Vector</code> <p>vector <code>v</code> with shape <code>(n,)</code> and random elements from discrete gaussian distribution.</p>"},{"location":"api/random/#pqlattice.random.distribution.DiscreteGaussian.set_params","title":"set_params","text":"<pre><code>set_params(\n    sigma: float | None = None,\n    center: float | int | None = None,\n    tail_cut: float | None = None,\n) -&gt; None\n</code></pre> <p>Set the parameters of the distribution</p> <p>Parameters:</p> Name Type Description Default <code>sigma</code> <code>float | None</code> <p>if None does nothing, by default None</p> <code>None</code> <code>center</code> <code>float | int | None</code> <p>if None does nothing, by default None</p> <code>None</code> <code>tail_cut</code> <code>float | None</code> <p>if None does nothing, by default None</p> <code>None</code>"},{"location":"api/random/#learning-with-errors","title":"Learning with errors","text":""},{"location":"api/random/#pqlattice.random.LWE","title":"pqlattice.random.LWE","text":"<pre><code>LWE(\n    n: int,\n    q: int,\n    sigma: float,\n    secret_distribution: str,\n    seed: int,\n)\n</code></pre> <p>Creates LWE sampler with DiscreteGuassianDistribution centered at 0 as noise sampler</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>length of secret vector</p> required <code>q</code> <code>int</code> <p>modulus</p> required <code>sigma</code> <code>float</code> <p>sigma value for DiscreteGaussianDistribution</p> required <code>seed</code> <code>int</code> <p>seed for random number generator</p> required"},{"location":"api/random/#pqlattice.random.LWE.secret","title":"secret  <code>property</code>","text":"<pre><code>secret: Vector\n</code></pre> <p>Retrieve underlying secret</p> <p>Returns:</p> Type Description <code>Vector</code> <p>s: n-vector</p>"},{"location":"api/random/#pqlattice.random.LWE.next_sample","title":"next_sample","text":"<pre><code>next_sample() -&gt; tuple[Vector, int]\n</code></pre> <p>Generates a single sample pair (a, b).</p> <p>Returns:</p> Type Description <code>tuple[Vector, int]</code> <p>a (Vector): n-vector (Uniform mod q) b (int): as + e mod q</p>"},{"location":"api/random/#pqlattice.random.LWE.sample_matrix","title":"sample_matrix","text":"<pre><code>sample_matrix(m: int) -&gt; tuple[Matrix, Vector]\n</code></pre> <p>Generates a full matrix system (A, b) with 'm' samples.</p> <p>Parameters:</p> Name Type Description Default <code>m</code> <code>int</code> <p>how many samples should the resulting matrix have</p> required <p>Returns:</p> Type Description <code>tuple[Matrix, Vector]:</code> <p>A (Matrix): m x n matrix (Uniform mod q) b (Vector): m-vector (As + e mod q)</p>"},{"location":"api/random/#pqlattice.random.LWE.set_secret","title":"set_secret","text":"<pre><code>set_secret(secret: Vector) -&gt; None\n</code></pre> <p>Set the underlying secret</p> <p>Parameters:</p> Name Type Description Default <code>secret</code> <code>Vector</code> <p>secret vector to set</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>when lenght of the provided vector is not correct with the parameter of the LWE sampler</p>"},{"location":"api/random/#miscellaneous","title":"Miscellaneous","text":""},{"location":"api/random/#pqlattice.random.randlattice","title":"pqlattice.random.randlattice","text":"<pre><code>randlattice(\n    n: int,\n    det_upper_bound: int | None = None,\n    seed: int | None = None,\n) -&gt; SquareMatrix\n</code></pre> <p>Generates lattice basis by, first generating random square matrix in Hermite normal form and then by transforming it using random unimodular matrix.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>lattice's rank</p> required <code>det_upper_bound</code> <code>int | None</code> <p>upper bound of lattice volume, by default 2 ** n</p> <code>None</code> <code>seed</code> <code>int | None</code> <p>seed for random number generator</p> <code>None</code> <p>Returns:</p> Type Description <code>SquareMatrix</code> <p>n x n matrix representing lattice basis</p>"},{"location":"api/random/#pqlattice.random.randprime","title":"pqlattice.random.randprime","text":"<pre><code>randprime(kbits: int, seed: int | None = None) -&gt; int\n</code></pre> <p>Generates random prime number from range [2 ** (kbits - 1); 2 ** (kbist)]. Uses Miller-Rabin primality test.</p> <p>Parameters:</p> Name Type Description Default <code>kbits</code> <code>int</code> <p>number of bits the prime number should have</p> required <code>seed</code> <code>int | None</code> <p>seed for random number generator, by default None</p> <code>None</code> <p>Returns:</p> Type Description <code>int</code> <p>prime number</p>"},{"location":"api/typing/","title":"Typing module","text":""},{"location":"api/typing/#aliases","title":"Aliases","text":"<pre><code>from typing import Any\n\nfrom numpy.typing import NDArray\n\ntype Array = NDArray[Any]\n\ntype Vector = NDArray[Any]\ntype Matrix = NDArray[Any]\ntype SquareMatrix = NDArray[Any]\n</code></pre>"},{"location":"api/typing/#predicates","title":"Predicates","text":""},{"location":"api/typing/#pqlattice.typing.is_Vector","title":"pqlattice.typing.is_Vector","text":"<pre><code>is_Vector(obj: Any) -&gt; TypeGuard[Vector]\n</code></pre>"},{"location":"api/typing/#pqlattice.typing.is_Matrix","title":"pqlattice.typing.is_Matrix","text":"<pre><code>is_Matrix(obj: Any) -&gt; TypeGuard[Matrix]\n</code></pre>"},{"location":"api/typing/#pqlattice.typing.is_SquareMatrix","title":"pqlattice.typing.is_SquareMatrix","text":"<pre><code>is_SquareMatrix(obj: Any) -&gt; TypeGuard[SquareMatrix]\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":""},{"location":"development/testing/#property-based-testing-using-hypothesis","title":"Property based testing using hypothesis","text":""},{"location":"development/testing/#sagemath-integration","title":"SageMath integration","text":""},{"location":"examples/LWE_dual_attack/","title":"LWE dual attack","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install \"pqlattice[fast]\"\n</pre> !pip install \"pqlattice[fast]\" In\u00a0[1]: Copied! <pre>import pqlattice as pq\nimport numpy as np\nimport math\npq.settings.set_backend(\"fast\")\n</pre> import pqlattice as pq import numpy as np import math pq.settings.set_backend(\"fast\") In\u00a0[2]: Copied! <pre>n = 20\nsigma = 2\nq = 1000\nm = 100\nsecret_dist = \"ternary\"\n\npossible_values = []\nif secret_dist == \"binary\":\n    possible_values = [0, 1]\nelif secret_dist == \"ternary\":\n    possible_values = [-1, 0, 1]\n</pre> n = 20 sigma = 2 q = 1000 m = 100 secret_dist = \"ternary\"  possible_values = [] if secret_dist == \"binary\":     possible_values = [0, 1] elif secret_dist == \"ternary\":     possible_values = [-1, 0, 1] In\u00a0[3]: Copied! <pre>lwe = pq.random.LWE(n, q, sigma, secret_dist, 42)\nsecret = lwe.secret\nA, b = lwe.sample_matrix(m)\n</pre> lwe = pq.random.LWE(n, q, sigma, secret_dist, 42) secret = lwe.secret A, b = lwe.sample_matrix(m) In\u00a0[4]: Copied! <pre>recovered_secret = []\n\nprint(\"Recovering secret's components\")\nfor i in range(n):\n    A_punctured = np.delete(A, i, axis=1)\n    G_dual = pq.lattice.embeddings.sis_basis(A_punctured, q)\n    target_column = A[:, i]\n    v = pq.lattice.bkz(G_dual, 20)[0]\n    interaction = np.dot(v, target_column)\n    \n    best_guess = 0\n    max_score = -float('inf')\n    \n    projection = np.dot(v, b)\n    \n    for guess in possible_values:\n        \n        correction = guess * interaction\n        z = (projection - correction) % q\n        score = math.cos((2 * math.pi * z) / q)\n        \n        if score &gt; max_score:\n            max_score = score\n            best_guess = guess\n            \n    recovered_secret.append(best_guess)\n    \n    is_correct = (best_guess == secret[i])\n    status = \"OK\" if is_correct else \"FAIL\"\n    print(f\"s[{i:2}]: guessed {best_guess:2} (score: {max_score:.4f}) -&gt; {status}\")\n\nprint()\nprint(\"Real secret:\")\nprint(f\"{pq.as_integer(secret)}\")\nprint(\"Recovered secret:\")\nprint(f\"{pq.as_integer(recovered_secret)}\")\naccuracy = (pq.as_integer(recovered_secret) == pq.as_integer(secret)).sum() / len(secret)\nprint()\nprint(f\"accuracy: {accuracy*100:.2f}\")\n</pre> recovered_secret = []  print(\"Recovering secret's components\") for i in range(n):     A_punctured = np.delete(A, i, axis=1)     G_dual = pq.lattice.embeddings.sis_basis(A_punctured, q)     target_column = A[:, i]     v = pq.lattice.bkz(G_dual, 20)[0]     interaction = np.dot(v, target_column)          best_guess = 0     max_score = -float('inf')          projection = np.dot(v, b)          for guess in possible_values:                  correction = guess * interaction         z = (projection - correction) % q         score = math.cos((2 * math.pi * z) / q)                  if score &gt; max_score:             max_score = score             best_guess = guess                  recovered_secret.append(best_guess)          is_correct = (best_guess == secret[i])     status = \"OK\" if is_correct else \"FAIL\"     print(f\"s[{i:2}]: guessed {best_guess:2} (score: {max_score:.4f}) -&gt; {status}\")  print() print(\"Real secret:\") print(f\"{pq.as_integer(secret)}\") print(\"Recovered secret:\") print(f\"{pq.as_integer(recovered_secret)}\") accuracy = (pq.as_integer(recovered_secret) == pq.as_integer(secret)).sum() / len(secret) print() print(f\"accuracy: {accuracy*100:.2f}\") <pre>Recovering secret's components\ns[ 0]: guessed -1 (score: 0.9913) -&gt; OK\ns[ 1]: guessed -1 (score: 0.9972) -&gt; OK\ns[ 2]: guessed  0 (score: 0.9950) -&gt; OK\ns[ 3]: guessed -1 (score: 0.9987) -&gt; OK\ns[ 4]: guessed  1 (score: 0.9929) -&gt; OK\ns[ 5]: guessed  0 (score: 0.9967) -&gt; OK\ns[ 6]: guessed -1 (score: 0.9905) -&gt; OK\ns[ 7]: guessed  0 (score: 0.9998) -&gt; OK\ns[ 8]: guessed  0 (score: 0.9967) -&gt; OK\ns[ 9]: guessed  1 (score: 1.0000) -&gt; OK\ns[10]: guessed  1 (score: 0.9961) -&gt; OK\ns[11]: guessed  1 (score: 0.9967) -&gt; OK\ns[12]: guessed  0 (score: 0.9995) -&gt; OK\ns[13]: guessed -1 (score: 0.9834) -&gt; OK\ns[14]: guessed  1 (score: 0.9921) -&gt; OK\ns[15]: guessed  0 (score: 0.9943) -&gt; OK\ns[16]: guessed -1 (score: 1.0000) -&gt; OK\ns[17]: guessed  1 (score: 0.9997) -&gt; OK\ns[18]: guessed -1 (score: 0.9856) -&gt; OK\ns[19]: guessed  1 (score: 0.9686) -&gt; OK\n\nReal secret:\n[-1 -1 0 -1 1 0 -1 0 0 1 1 1 0 -1 1 0 -1 1 -1 1]\nRecovered secret:\n[-1 -1 0 -1 1 0 -1 0 0 1 1 1 0 -1 1 0 -1 1 -1 1]\n\naccuracy: 100.00\n</pre>"},{"location":"examples/LWE_primary_attack/","title":"LWE primary attack","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install \"pqlattice[fast]\"\n</pre> !pip install \"pqlattice[fast]\" In\u00a0[1]: Copied! <pre>import pqlattice as pq\nimport numpy as np\nimport math\npq.settings.set_backend(\"fast\")\n</pre> import pqlattice as pq import numpy as np import math pq.settings.set_backend(\"fast\") In\u00a0[2]: Copied! <pre>n = 14\nsigma = 2\nq = 1000\nm = 50\nsecret_dist = \"ternary\"\n\npossible_values = []\nif secret_dist == \"binary\":\n    possible_values = [0, 1]\nelif secret_dist == \"ternary\":\n    possible_values = [-1, 0, 1]\n</pre> n = 14 sigma = 2 q = 1000 m = 50 secret_dist = \"ternary\"  possible_values = [] if secret_dist == \"binary\":     possible_values = [0, 1] elif secret_dist == \"ternary\":     possible_values = [-1, 0, 1] In\u00a0[3]: Copied! <pre>lwe = pq.random.LWE(n, q, sigma, secret_dist, 80)\nsecret = lwe.secret\nA, b = lwe.sample_matrix(m)\n</pre> lwe = pq.random.LWE(n, q, sigma, secret_dist, 80) secret = lwe.secret A, b = lwe.sample_matrix(m) In\u00a0[4]: Copied! <pre>K = pq.lattice.embeddings.kannan(A, b, q)\npq.show(K)\n</pre> K = pq.lattice.embeddings.kannan(A, b, q) pq.show(K) <pre>Matrix of integers with shape: 65 x 65\n======================================\n       [0]   [1]   [2]   [3]   [4]  ...  [60]  [61]  [62]  [63]  [64]\n [0]  1000     0     0     0     0  ...     0     0     0     0     0\n [1]     0  1000     0     0     0  ...     0     0     0     0     0\n [2]     0     0  1000     0     0  ...     0     0     0     0     0\n [3]     0     0     0  1000     0  ...     0     0     0     0     0\n [4]     0     0     0     0  1000  ...     0     0     0     0     0\n ...   ...   ...   ...   ...   ...  ...   ...   ...   ...   ...   ...\n[60]   398   382   764   104   492  ...     1     0     0     0     0\n[61]   247   361     4   249   799  ...     0     1     0     0     0\n[62]   173   606   153   649   685  ...     0     0     1     0     0\n[63]   968   177   540   508   354  ...     0     0     0     1     0\n[64]   -16  -549  -665  -753  -979  ...     0     0     0     0     1\n</pre> In\u00a0[5]: Copied! <pre>L = pq.lattice.lll(K)\nprint(pq.linalg.norm(L[0]))\n</pre> L = pq.lattice.lll(K) print(pq.linalg.norm(L[0])) <pre>13.30413469565007\n</pre> In\u00a0[6]: Copied! <pre>B = pq.lattice.bkz(L)\nprint(pq.linalg.norm(B[0]))\n</pre> B = pq.lattice.bkz(L) print(pq.linalg.norm(B[0])) <pre>13.30413469565007\n</pre> In\u00a0[7]: Copied! <pre>v = B[0]\ne = v[:m]\ns = v[m:m + n]\n\nprint(\"Recovered noise: \", e)\nprint()\nprint(\"Recovered secret:\", s)\nprint(\"True secret:     \", secret)\n</pre> v = B[0] e = v[:m] s = v[m:m + n]  print(\"Recovered noise: \", e) print() print(\"Recovered secret:\", s) print(\"True secret:     \", secret) <pre>Recovered noise:  [-1 -4 -1 -3 0 1 0 0 1 3 2 0 2 1 -1 -1 1 6 0 0 -1 1 0 2 -1 1 0 -2 2 1 1 0\n 1 0 1 -2 0 -2 -3 1 -1 3 -2 1 -1 3 3 -2 2 -1]\n\nRecovered secret: [1 0 1 1 1 0 -1 0 1 0 1 1 1 0]\nTrue secret:      [1 0 1 1 1 0 -1 0 1 0 1 1 1 0]\n</pre>"},{"location":"examples/LWE_primary_attack/#primary-attack-on-search-lwe-problem","title":"Primary attack on search-LWE problem\u00b6","text":"<p>In this notebook we are going to solve search-LWE by using primary attack. First let's define the LWE. Given parameters $n, q \\in \\mathbb{Z} $ and some non-uniform probability distribution $\\chi$ on $\\mathbb{Z}_q$ we define an LWE sample $(\\mathbf{a},b)$ for a secret vector $\\mathbf{s} \\in {\\mathbb{Z}^n_q}$ as follows $$ \\begin{align*} \\mathbf{a} &amp;\\leftarrow \\operatorname{Uniform}(\\mathbb{Z}^n_q) \\newline b &amp;:= \\langle \\mathbf{a}, \\mathbf{s}\\rangle + e \\end{align*} $$ where error $e$ is sampled from $\\chi$ distribution. $$ \\mathbf{e} \\leftarrow \\chi $$ As we take more samples, we can arrange them into a matrix/vector form. So for $m$ samples we define matrix $A \\in \\mathbb{Z}^{m\\times n}_q$ to be obtained from uniform distribution and use vector $\\mathbf{e} \\in \\mathbb{Z}^m$ for error $$ \\begin{align*} A &amp;\\leftarrow \\operatorname{Uniform}(\\mathbb{Z}^{m\\times n}_q) \\newline \\mathbf{e} &amp;\\leftarrow \\chi^{m} \\newline \\mathbf{b} &amp;:= A\\mathbf{s} + \\mathbf{e} \\end{align*} $$ For search-LWE problem, given only pair $(A, \\mathbf{b})$ we need to obtain secret vector $\\mathbf{s}$.</p>"},{"location":"examples/attacking_congruential_pkc/","title":"Congruential PKC","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install pqlattice\n</pre> !pip install pqlattice In\u00a0[1]: Copied! <pre>import pqlattice as pq\n\nq = 122430513841\nf = 231241\ng = 195698\n\nassert 0 &lt; f &lt; (q/2) ** 0.5\nassert (q/4) ** 0.5 &lt; g &lt; (q/2) ** 0.5\nassert pq.integer.gcd(f, q * g) == 1\n\nR = pq.integer.ModIntRing(q)\n\nh = R.mul(R.inv(f), g)\n\npublic_key = h\nprivate_key = (f,g)\n\nprint(\"private key:\", private_key)\nprint(\"public key:\", public_key)\n</pre> import pqlattice as pq  q = 122430513841 f = 231241 g = 195698  assert 0 &lt; f &lt; (q/2) ** 0.5 assert (q/4) ** 0.5 &lt; g &lt; (q/2) ** 0.5 assert pq.integer.gcd(f, q * g) == 1  R = pq.integer.ModIntRing(q)  h = R.mul(R.inv(f), g)  public_key = h private_key = (f,g)  print(\"private key:\", private_key) print(\"public key:\", public_key) <pre>private key: (231241, 195698)\npublic key: 79751031608\n</pre> In\u00a0[2]: Copied! <pre>m = 123456\nr = 101010\n\nassert 0 &lt; m &lt; (q/4) ** 0.5\nassert 0 &lt; r &lt; (q/2) ** 0.5\n\nh = public_key\ne = R.mod(r * public_key + m)\n\nplaintext = m\nciphertext = e\n\nprint(\"plaintext:\", plaintext)\nprint(\"ciphertext:\", ciphertext)\n</pre> m = 123456 r = 101010  assert 0 &lt; m &lt; (q/4) ** 0.5 assert 0 &lt; r &lt; (q/2) ** 0.5  h = public_key e = R.mod(r * public_key + m)  plaintext = m ciphertext = e  print(\"plaintext:\", plaintext) print(\"ciphertext:\", ciphertext) <pre>plaintext: 123456\nciphertext: 91183651259\n</pre> In\u00a0[3]: Copied! <pre>f,g = private_key\ne = ciphertext\n\na = R.mul(f, e)\nG = pq.integer.ModIntRing(g)\nb = G.mod(G.inv(f) * a)\n\nprint(\"decrypted message:\", b)\n\nassert b == plaintext\n</pre> f,g = private_key e = ciphertext  a = R.mul(f, e) G = pq.integer.ModIntRing(g) b = G.mod(G.inv(f) * a)  print(\"decrypted message:\", b)  assert b == plaintext <pre>decrypted message: 123456\n</pre> In\u00a0[4]: Copied! <pre>v1 = pq.as_integer([1,h])\nv2 = pq.as_integer([0,q])\n\nV = pq.as_integer([v1, v2])\n\nW = pq.lattice.glr_2dim(V)\nw1 = W[0]\nw2 = W[1]\n\nprint(\"w1:\", w1, \"||w1||:\", pq.linalg.norm(w1))\nprint(\"w2:\", w1, \"||w2||:\", pq.linalg.norm(w2))\n\nF, G = w1\nprint()\n\nprint(\"F:\", F)\nprint(\"G:\", G)\n\nprint(\"secret f:\", f)\nprint(\"secret g:\", g)\n</pre> v1 = pq.as_integer([1,h]) v2 = pq.as_integer([0,q])  V = pq.as_integer([v1, v2])  W = pq.lattice.glr_2dim(V) w1 = W[0] w2 = W[1]  print(\"w1:\", w1, \"||w1||:\", pq.linalg.norm(w1)) print(\"w2:\", w1, \"||w2||:\", pq.linalg.norm(w2))  F, G = w1 print()  print(\"F:\", F) print(\"G:\", G)  print(\"secret f:\", f) print(\"secret g:\", g) <pre>w1: [-231241 -195698] ||w1||: 302935.8138038486\nw2: [-231241 -195698] ||w2||: 410253.69316192635\n\nF: -231241\nG: -195698\nsecret f: 231241\nsecret g: 195698\n</pre> <p>As we can see using only public parameters of the cryptosystem, we managed to retrieve secret key by interpreting the underlying problem as SVP in dimension 2 Lattice.</p>"},{"location":"examples/attacking_congruential_pkc/#attacking-a-congruential-public-key-cryptosystem-using-gaussian-lattice-reduction-in-2-dimension","title":"Attacking a congruential public key cryptosystem using Gaussian lattice reduction in 2 dimension\u00b6","text":"<p>In this example we use our library to first construct a Congruential Public Key Cryptosystem and then attack it and retrieve private key using Gaussian lattice reduction.</p>"},{"location":"examples/attacking_congruential_pkc/#congruential-public-key-cryptosystem","title":"Congruential Public Key cryptosystem\u00b6","text":""},{"location":"examples/attacking_congruential_pkc/#key-creation","title":"Key creation\u00b6","text":"<p>We start by choosing a large integer modulus $q$ which will be a public parameter of the cryptosystem. Then we need to choose two secret integers $f$ and $g$ that will form private key such that: $$ \\begin{aligned}  0 &lt; &amp;f &lt; \\sqrt{q/2} \\\\ \\sqrt{q/4} &lt; &amp;g &lt; \\sqrt{q/2} \\end{aligned} $$ We will be calculating multiplicative modular inverses so we need to make sure that they exists: $$ \\begin{aligned} \\gcd(f,q) &amp;= 1 \\\\ \\gcd(f,g) &amp;= 1 \\end{aligned} $$ we then calculate $$ h \\equiv f^{-1} g \\mod{q} $$ that value will serve as our public key. Let's see this in code</p>"},{"location":"examples/attacking_congruential_pkc/#encryption","title":"Encryption\u00b6","text":"<p>In order to perform encryption we have to chose plaintext integer $m$ that we want to encrypt and random integer $r$ that will serve as noise. $m$ must satisfy $ 0 &lt; m &lt; \\sqrt{q/4} $ and $r$ must satisfy $ 0 &lt; r &lt; \\sqrt{q/2} $. We can then use public key $h$ to compute ciphertext $e$ with the following formula: $$ e \\equiv rh + m \\mod{q} $$</p>"},{"location":"examples/attacking_congruential_pkc/#decryption","title":"Decryption\u00b6","text":"<p>We will use private key to decrypt the message. First we compute the intermidiate value $$ a \\equiv fe \\mod{q} $$ and then retrieve the plaintext $$ b \\equiv f^{-1}a \\mod{g} $$ it's important to notice that we calculate multiplicative inverse of $f$ modulo $g$ this time and not modulo $q$ as we did when creating the key. The $b$ should be equal plaintext $m$.</p>"},{"location":"examples/attacking_congruential_pkc/#attacking-the-cryptosystem","title":"Attacking the cryptosystem\u00b6","text":"<p>Unfortunetly this cryptosystem isn't very secure. In order to break it, all the attacker needs is to find two positive integers $F$ and $G$ that will satisfy the following equation $$ Fh \\equiv G \\mod{q} $$ and this integers have to be sufficiently small $$ F = \\mathcal{O}(\\sqrt{q}) \\quad \\textrm{and} \\quad G = \\mathcal{O}(\\sqrt{q}) $$ We can rewrite this congruence as $$ Fh = G + qR $$ It's then quite easy to reformulate this problem into finding shortest vector in lattice. Let's define two vectors $$ \\begin{aligned} v_1 &amp;= (1,h)\\\\ v_2 &amp;= (0,q) \\end{aligned} $$ To break the cryptosystem we have to find a linear combination $$ \\boldsymbol{w} = a_1 \\boldsymbol{v_1} + a_2 \\boldsymbol{v_2}; \\quad a_1, a_2 \\in \\mathbb{Z} $$ such that $\\boldsymbol{w}$ has length $\\mathcal{O}(\\sqrt{q})$. To put it in a lattice's terms. We need to find a short nonzero vector in the set of two-dimensional lattice $$ L = \\{a_1 \\boldsymbol{v_1} + a_2 \\boldsymbol{v_2} \\; : \\; a_1, a_2 \\in \\mathbb{Z} \\} $$ It turns out that for two dimensional lattices this problem is quite trivial</p>"},{"location":"examples/attacking_congruential_pkc/#gaussian-lattice-reduction-in-dimension-2","title":"Gaussian Lattice Reduction in Dimension 2\u00b6","text":""},{"location":"examples/attacking_discrete_knapsack_pkc/","title":"Subset sum PKC","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install pqlattice\n</pre> !pip install pqlattice In\u00a0[1]: Copied! <pre>import math\nimport itertools\nimport pqlattice as pq\nimport numpy as np\n</pre> import math import itertools import pqlattice as pq import numpy as np In\u00a0[2]: Copied! <pre>is_superincreasing = lambda xs: all((j &gt;= 2 * i for i,j in itertools.pairwise(xs)))\n\nr = [3,11,24,50,115]\nA = 113\nB = 250\n\nassert is_superincreasing(r)\nassert B &gt; 2 * r[-1]\nassert math.gcd(A,B) == 1\n\nM = [(A * ri) % B for ri in r]\n\nassert not is_superincreasing(M)\n\nprivate_key = (r, A, B)\npublic_key = M\n\nprint(\"private key:\", private_key)\nprint(\"public key:\", public_key)\n</pre> is_superincreasing = lambda xs: all((j &gt;= 2 * i for i,j in itertools.pairwise(xs)))  r = [3,11,24,50,115] A = 113 B = 250  assert is_superincreasing(r) assert B &gt; 2 * r[-1] assert math.gcd(A,B) == 1  M = [(A * ri) % B for ri in r]  assert not is_superincreasing(M)  private_key = (r, A, B) public_key = M  print(\"private key:\", private_key) print(\"public key:\", public_key) <pre>private key: ([3, 11, 24, 50, 115], 113, 250)\npublic key: [89, 243, 212, 150, 245]\n</pre> In\u00a0[3]: Copied! <pre>x = [1,0,1,0,1]\nS = sum((xi * Mi for xi, Mi in zip(x, M) if xi))\n\nplaintext = x\nciphertext = S\n\nprint(\"plaintext:\", plaintext)\nprint(\"ciphertext:\", ciphertext)\n</pre> x = [1,0,1,0,1] S = sum((xi * Mi for xi, Mi in zip(x, M) if xi))  plaintext = x ciphertext = S  print(\"plaintext:\", plaintext) print(\"ciphertext:\", ciphertext) <pre>plaintext: [1, 0, 1, 0, 1]\nciphertext: 546\n</pre> In\u00a0[4]: Copied! <pre>r, A, B = private_key\nM = public_key\nS = ciphertext\n\nSprim = (pq.integer.modinv(A, B) * S) % B\n\n\ny = [0 for _ in r]\nfor i, ri in enumerate(r[::-1]):\n    if ri &lt;= Sprim:\n        y[i] = 1\n        Sprim = Sprim - ri\n\ny = y[::-1]\nprint(\"decrypted message:\", y)\nassert y == x\n</pre> r, A, B = private_key M = public_key S = ciphertext  Sprim = (pq.integer.modinv(A, B) * S) % B   y = [0 for _ in r] for i, ri in enumerate(r[::-1]):     if ri &lt;= Sprim:         y[i] = 1         Sprim = Sprim - ri  y = y[::-1] print(\"decrypted message:\", y) assert y == x <pre>decrypted message: [1, 0, 1, 0, 1]\n</pre> In\u00a0[5]: Copied! <pre>n = len(M)\nA = pq.as_integer(np.identity(n + 1) * 2)\nA[-1] = 1\nA[:-1,-1] = M\nA[-1,-1] = S\nprint(\"Subset sum lattice\")\npq.show(A)\n\nA_lll = pq.lattice.lll(A)\nw = A_lll[0]\nprint(\"short vector in LLL reduced basis:\")\nprint(\"w = \", w)\nx = pq.as_integer(w @ np.linalg.inv(A.astype(float)))\n\nx, y = x[:-1], x[-1]\nprint(x)\nprint(np.dot(np.array(M), x))\nprint(-y * S)\n</pre> n = len(M) A = pq.as_integer(np.identity(n + 1) * 2) A[-1] = 1 A[:-1,-1] = M A[-1,-1] = S print(\"Subset sum lattice\") pq.show(A)  A_lll = pq.lattice.lll(A) w = A_lll[0] print(\"short vector in LLL reduced basis:\") print(\"w = \", w) x = pq.as_integer(w @ np.linalg.inv(A.astype(float)))  x, y = x[:-1], x[-1] print(x) print(np.dot(np.array(M), x)) print(-y * S) <pre>Subset sum lattice\nMatrix of integers with shape: 6 x 6\n====================================\n     [0]  [1]  [2]  [3]  [4]  [5]\n[0]    2    0    0    0    0   89\n[1]    0    2    0    0    0  243\n[2]    0    0    2    0    0  212\n[3]    0    0    0    2    0  150\n[4]    0    0    0    0    2  245\n[5]    1    1    1    1    1  546\nshort vector in LLL reduced basis:\nw =  [-1 1 -1 1 -1 0]\n[-1 0 -1 0 -1]\n-546\n-546\n</pre>"},{"location":"examples/attacking_discrete_knapsack_pkc/#attacking-a-discrete-knapsack-public-key-cryptosystem-using-lll-lattice-reduction","title":"Attacking a Discrete Knapsack Public Key Cryptosystem using LLL lattice reduction\u00b6","text":"<p>In this example we will use our library to construct a Discrete Knapsack Public Key Cryptosystem and then attack it and retrieve private key using LLL lattice reduction</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#discrete-knapsack-public-key-cryptosystem","title":"Discrete Knapsack Public Key Cryptosystem\u00b6","text":"<p>In this cryptosystem we assume security by using Discrete Knapsack Packing Problem which is NP-hard. In theory this should a be very strong assurance. However in practice in order to create a trapdoor we will have to use special kind of sequences (superincreasing sequences), that will allow us to find and exploit vulnerabilities of the cryptosystem without actually solving the underlying general NP-hard problem.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#discrete-knapsack-packing-problem","title":"Discrete Knapsack Packing Problem\u00b6","text":"<p>Given a list of positive integers $(M_1, M_2, ..., M_n)$ and another integer $S$ find a subset of the elements in the list that sums to $S$. This problem in general is very hard to solve. However if we use so called superincreasing sequences as our list, we can use straightforward greedy algorithm to find a solution. We say that list of positive integers $(r_1, r_2, ... , r_n)$ is superincreasing if $$ r_{i+1} \\geq 2r_i \\quad \\text{for all} \\; 1 \\leq i \\leq n - 1 $$ If we are asked to solve knapsack problem $(M, S)$, where $M$ is integer sequence and $S$ is the sum we have to obtain then if $M$ is superincreasing sequence we can find a solution with following algorithm. $$ \\begin{aligned} \\text{1.} &amp; \\text{find the largest element of} \\; M \\; \\text{that is smaller than} \\; S. \\newline \\text{2.} &amp; \\text{subtract this element from} \\; S. \\newline \\text{3.} &amp; \\text{repeat until the problem is solved}. \\end{aligned} $$</p> <p>The idea behind Discrete Knapsack Cryptosystems is quite simple. If we could construct superincreasing sequence and somehow obstruct it to the public eye, then it would appear that the best way to solve it is by using some kind of exponential algorithm. We could however easily find the solution by utilizing the greedy algorithm on unobstucted sequence.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#key-creation","title":"Key creation\u00b6","text":"<p>Let's choose some superincreasing sequence $\\boldsymbol{r} = (r_1, ...., r_n)$ and two large secret integers $A$ and $B$ satisfying $$     B &gt; 2r_n \\quad \\text{and} \\quad \\gcd(A,B) = 1. $$ We can then create new sequence $\\boldsymbol{M}$ that is not superincreasing with the following method $$ M_i \\equiv Ar_i \\mod B \\quad \\text{for all} \\; 1 \\leq i \\leq n $$ $(\\boldsymbol{r}, A, B)$ is our private key and $\\boldsymbol{M}$ is our public key.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#encryption","title":"Encryption\u00b6","text":"<p>Our plaintext has a form of binary vector $\\boldsymbol{x}$ $i_{th}$ coefficient of the vector indicates if we count the $i_{th}$ sequence element into the knapsack sum. The obtained sum $S$ is our ciphertext.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#decryption","title":"Decryption\u00b6","text":"<p>Upon receiving the sum $S$. We can transform it into \"space\" of our superincreasing sequence $$ S' \\equiv A^{-1} S \\mod{B} $$ Then we use the greedy algorithm on our secret superincreasing sequence to find the binary vector $\\boldsymbol{y}$ that will be our decrypted message.</p>"},{"location":"examples/attacking_discrete_knapsack_pkc/#attacking-the-cryptosystem","title":"Attacking the cryptosystem\u00b6","text":""},{"location":"examples/constructing_and_attacking_GGH_pkc/","title":"GGH PKC","text":"In\u00a0[1]: Copied! <pre>import pqlattice as pq\nimport numpy as np\n</pre> import pqlattice as pq import numpy as np In\u00a0[2]: Copied! <pre># let's choose the vectors for a good basis\nv1 = pq.as_integer([-97, 19, 19])\nv2 = pq.as_integer([-36, 30, 86])\nv3 = pq.as_integer([-184, -64, 78])\n\nV = pq.as_integer([v1, v2, v3])\nprint(\"Good basis V\")\npq.show(V)\n\nprint(f\"Hadamard ratio for V: {pq.lattice.hadamard_ratio(V):.2f}\")\nprint()\n# Now let's calculate bad basis W as a Hermite normal form of V\nW, _ = pq.linalg.hnf(V)\nprint(\"Bad basis W:\")\npq.show(W)\nprint(f\"Hadamard ratio for W: {pq.lattice.hadamard_ratio(W)}\")\n</pre> # let's choose the vectors for a good basis v1 = pq.as_integer([-97, 19, 19]) v2 = pq.as_integer([-36, 30, 86]) v3 = pq.as_integer([-184, -64, 78])  V = pq.as_integer([v1, v2, v3]) print(\"Good basis V\") pq.show(V)  print(f\"Hadamard ratio for V: {pq.lattice.hadamard_ratio(V):.2f}\") print() # Now let's calculate bad basis W as a Hermite normal form of V W, _ = pq.linalg.hnf(V) print(\"Bad basis W:\") pq.show(W) print(f\"Hadamard ratio for W: {pq.lattice.hadamard_ratio(W)}\") <pre>Good basis V\nMatrix of integers with shape: 3 x 3\n====================================\n      [0]  [1]  [2]\n[0]   -97   19   19\n[1]   -36   30   86\n[2]  -184  -64   78\nHadamard ratio for V: 0.75\n\nBad basis W:\nMatrix of integers with shape: 3 x 3\n====================================\n     [0]  [1]     [2]\n[0]    1    1  285737\n[1]    0    2  181486\n[2]    0    0  429758\nHadamard ratio for W: 0.000337862606922202\n</pre> In\u00a0[3]: Copied! <pre>r = pq.as_integer([-4, -3, 2])\nm = pq.as_integer([86, -35, -32])\n\ne = m @ W + r\n\nprint(f\"Encrypted message e: {e}\")\n</pre> r = pq.as_integer([-4, -3, 2]) m = pq.as_integer([86, -35, -32])  e = m @ W + r  print(f\"Encrypted message e: {e}\") <pre>Encrypted message e: [82 13 4469118]\n</pre> In\u00a0[4]: Copied! <pre>x = pq.lattice.babai_closest_vector(V, e)\nd = pq.as_integer((x @ V) @ np.linalg.inv(W.astype(float)))\nprint(f\"Message m: {m}\")\nprint(f\"Decrypted message d: {d}\")\nassert np.all(m == d)\n</pre> x = pq.lattice.babai_closest_vector(V, e) d = pq.as_integer((x @ V) @ np.linalg.inv(W.astype(float))) print(f\"Message m: {m}\") print(f\"Decrypted message d: {d}\") assert np.all(m == d) <pre>Message m: [86 -35 -32]\nDecrypted message d: [86 -35 -32]\n</pre> <p>Let's also try to decrypt the message using only public key $W$. Then $ y = \\text{babai}(W, e) \\cdot W $.</p> In\u00a0[5]: Copied! <pre>y = pq.lattice.babai_closest_vector(W, e) @ W\nprint(f\"Message m: {m}\")\nprint(f\"Decrypted message y: {y}\")\n</pre> y = pq.lattice.babai_closest_vector(W, e) @ W print(f\"Message m: {m}\") print(f\"Decrypted message y: {y}\") <pre>Message m: [86 -35 -32]\nDecrypted message y: [82 14 4367170]\n</pre> <p>Because $W$ is a bad basis, Babai's algorithm gives a very bad approximation for CVP, hence the message is incorrectly decrypted.</p> In\u00a0[6]: Copied! <pre>L = pq.lattice.lll(W)\nprint(\"LLL reduced basis\")\npq.show(L)\nprint(f\"Hadamard ratio for L: {pq.lattice.hadamard_ratio(L):.2f}\")\n\ns = pq.lattice.babai_closest_vector(L, e)\ns = pq.as_integer((s @ L) @ np.linalg.inv(W.astype(float)))\n\nprint(f\"Message m: {m}\")\nprint(f\"Decrypted message s: {s}\")\nassert np.all(m==s)\n</pre> L = pq.lattice.lll(W) print(\"LLL reduced basis\") pq.show(L) print(f\"Hadamard ratio for L: {pq.lattice.hadamard_ratio(L):.2f}\")  s = pq.lattice.babai_closest_vector(L, e) s = pq.as_integer((s @ L) @ np.linalg.inv(W.astype(float)))  print(f\"Message m: {m}\") print(f\"Decrypted message s: {s}\") assert np.all(m==s) <pre>LLL reduced basis\nMatrix of integers with shape: 3 x 3\n====================================\n     [0]   [1]  [2]\n[0]  -61   -11  -67\n[1]  -36    30   86\n[2]   10  -102   40\nHadamard ratio for L: 0.96\nMessage m: [86 -35 -32]\nDecrypted message s: [86 -35 -32]\n</pre> <p>Using only public key $W$ we managed to decrypt the message $e$ by utilizing the LLL algorithm.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#constructing-and-attacking-ggh-public-key-cryptosystem","title":"Constructing and attacking GGH public key cryptosystem\u00b6","text":"<p>GGH cryptosystem named after it's authors - Goldwasser, Goldreich and Halevi is one of the earlier cryptosystems based on some lattice problem. In case for GGH the underlying problem is CVP (Closest Vector Problem). In order to construct a trapdoor, the concept of good and bad basis is created. Although the GGH has already been already successfully cryptanalyzed for practical parameters sizes, due to it's relative simplicity it serves as a good introduction to latticed based cryptography and cryptanalysis.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#ggh-public-key-cryptosystem","title":"GGH Public Key Cryptosystem\u00b6","text":"<p>The key concept behind the GGH cryptosystem is the notion of good and bad basis. Good basis consists of relativly short and orthogonal lattice vectors, which allows (with correctly choosen parameters) for solving CVP with sufficiently good approximation. Bad basis consists of long and highly non-orthogonal lattice vectors.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#key-creation","title":"Key creation\u00b6","text":"<p>Let's strart by choosing a set of linearly independent vectors that will server as a good basis (to check whether a basis is good we can calculate it's Hadamard ratio) $$ v_1,...,v_n \\in \\mathbb{Z}^{n} $$ Let $V$ be a $n$-by-$n$ matrix whose rows are the vectors $v_1, ..., v_n$ $$ \\begin{bmatrix} v_1 \\newline \\vdots \\newline v_n \\end{bmatrix} $$ In order to create the hardest possible basis that spans the same lattice we can use the Hermite normal form of the matrix $V$, which is an analogue of reduced echelon form for matrices over the integers $\\mathbb{Z}$ and is the same for every basis of a given lattice. Let $$ W = \\text{hnf}(V) $$ The $V$ matrix is a good basis and will serve as a private key, while the matrix $W$ is a bad basis and will be used as public key.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#encryption","title":"Encryption\u00b6","text":"<p>Let $ m \\in \\mathbb{Z}^{n} $ be an integer vector representing plaintext that is to be encrypted and   $r \\in \\mathbb{R}^{n}$ be a small perturbation vector that will act as a noise. In order to encrypt vector $m$ using public key $W$ and noise vector $r$ we compute $$ e = m \\cdot W + r $$ because we add noise vector $r$, the vector $e$ is not a lattice point itself, but it should be close to the lattice point $mW$ since $r$ is small. The vector $e$ is our encrypted message.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#decryption","title":"Decryption\u00b6","text":"<p>In order to decrypt vector $e$ we wil use Babai's algorithm. Given some lattice basis $B$ and some vector $w$, Babai's algorithm will find approxCVP in a following way $$ \\begin{aligned} \\text{1.} &amp; \\text{Write the vector} \\; w \\; \\text{in coordinates of basis} \\; B \\; \\text{by solving} \\; w = x \\cdot B.\\newline \\text{2.} &amp; \\; x \\in \\mathbb{R}^{n} \\; \\text{so round it's coefficients to the nearest integer.}\\newline \\text{3.} &amp; \\text{return x.} \\end{aligned} $$ $$ x = \\text{babai}(V,e) $$ Vector $x$ is written using private basis, so to get to the message we need to change basis to public basis. $$ d = (x \\cdot V) \\cdot W^{-1} $$ Vector $d$ is the encrypted message.</p>"},{"location":"examples/constructing_and_attacking_GGH_pkc/#attacking-the-underlying-problem","title":"Attacking the underlying problem\u00b6","text":"<p>Unfortunetly GGH cryptosystem is not very secure. The only thing we need to break it, is to somehow transform a known bad basis $W$ into some better basis $M$. We can use the LLL algorithm to do just that.</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/","title":"NTRU PKC","text":"In\u00a0[\u00a0]: Copied! <pre>!pip install pqlattice\n</pre> !pip install pqlattice In\u00a0[1]: Copied! <pre>import pqlattice as pq\n</pre> import pqlattice as pq In\u00a0[2]: Copied! <pre># Let's choose NTRU parameters and private key (f,g)\nN, p, q, d = 7, 3, 41, 2\nRq = pq.polynomial.construct_ring(\"-\", N, q) #(X^N + 1)\nRp = pq.polynomial.construct_ring(\"-\", N, p) #(X^N + 1)\n\nf = pq.as_integer([-1, 0, 1, 1, -1, 0, 1]) #f(x) = x^6 - x^4 + x^3 + x^2 - 1\ng = pq.as_integer([0, -1, -1, 0, 1, 0, 1]) #g(x) = x^6 + x^4 - x^2 - x\n</pre> # Let's choose NTRU parameters and private key (f,g) N, p, q, d = 7, 3, 41, 2 Rq = pq.polynomial.construct_ring(\"-\", N, q) #(X^N + 1) Rp = pq.polynomial.construct_ring(\"-\", N, p) #(X^N + 1)  f = pq.as_integer([-1, 0, 1, 1, -1, 0, 1]) #f(x) = x^6 - x^4 + x^3 + x^2 - 1 g = pq.as_integer([0, -1, -1, 0, 1, 0, 1]) #g(x) = x^6 + x^4 - x^2 - x In\u00a0[3]: Copied! <pre># Now lets compute inverses Fq and Fp\nFq = Rq.inv(f)\nFp = Rp.inv(f)\n\n# Lets check if the inverses are correct\nprint(\"f^-1 in Rq:\")\nprint(Fq)\nprint(\"f * f^-1:\", Rq.mul(f, Fq))\nprint()\nprint(\"f^-1 in Rp:\")\nprint(Fp)\nprint(\"f * f^-1:\", Rp.mul(f, Fp))\nprint()\n\n\n# Now let's calculate public key h\nh = Rq.mul(Fq, g)\nprint(\"h = Fq * g:\")\nprint(h)\nprint()\n\nprint(\"Private key: (f(x), Fp(x))\")\nprint(\"f(x) = \", f)\nprint(\"g(x) = \", g)\nprint()\nprint(\"Public key: h(x)\")\nprint(\"h(x) = \", h)\n\nsk = (f, Fp)\npk = h\n</pre> # Now lets compute inverses Fq and Fp Fq = Rq.inv(f) Fp = Rp.inv(f)  # Lets check if the inverses are correct print(\"f^-1 in Rq:\") print(Fq) print(\"f * f^-1:\", Rq.mul(f, Fq)) print() print(\"f^-1 in Rp:\") print(Fp) print(\"f * f^-1:\", Rp.mul(f, Fp)) print()   # Now let's calculate public key h h = Rq.mul(Fq, g) print(\"h = Fq * g:\") print(h) print()  print(\"Private key: (f(x), Fp(x))\") print(\"f(x) = \", f) print(\"g(x) = \", g) print() print(\"Public key: h(x)\") print(\"h(x) = \", h)  sk = (f, Fp) pk = h <pre>f^-1 in Rq:\n[37 2 40 21 31 26 8]\nf * f^-1: [1]\n\nf^-1 in Rp:\n[1 1 1 1 0 2 1]\nf * f^-1: [1]\n\nh = Fq * g:\n[30 26 8 38 2 40 20]\n\nPrivate key: (f(x), Fp(x))\nf(x) =  [-1 0 1 1 -1 0 1]\ng(x) =  [0 -1 -1 0 1 0 1]\n\nPublic key: h(x)\nh(x) =  [30 26 8 38 2 40 20]\n</pre> In\u00a0[4]: Copied! <pre># plaintext\nm = pq.as_integer([ 1,-1, 1, 1, 0,-1])\nprint(\"plaintext m(x) =\", m)\n# random element\nr = pq.as_integer([-1, 1, 0, 0, 0,-1, 1])\nprint(\"random element r(x) =\", r) \n\nprint()\n# ciphertext\ne = Rq.add(p * Rq.mul(r, pk), m)\nprint(\"ciphertext e(x) =\", e)\n</pre> # plaintext m = pq.as_integer([ 1,-1, 1, 1, 0,-1]) print(\"plaintext m(x) =\", m) # random element r = pq.as_integer([-1, 1, 0, 0, 0,-1, 1]) print(\"random element r(x) =\", r)   print() # ciphertext e = Rq.add(p * Rq.mul(r, pk), m) print(\"ciphertext e(x) =\", e) <pre>plaintext m(x) = [1 -1 1 1 0 -1]\nrandom element r(x) = [-1 1 0 0 0 -1 1]\n\nciphertext e(x) = [25 3 40 2 4 19 31]\n</pre> In\u00a0[5]: Copied! <pre>a = Rq.center_lift(Rq.mul(sk[0], e))\nd = Rp.center_lift(Rp.mul(sk[1], a))\nprint(\"Decrypted message d:\")\nprint(d)\nprint(\"Original message m:\")\nprint(m)\n</pre> a = Rq.center_lift(Rq.mul(sk[0], e)) d = Rp.center_lift(Rp.mul(sk[1], a)) print(\"Decrypted message d:\") print(d) print(\"Original message m:\") print(m) <pre>Decrypted message d:\n[1 -1 1 1 0 -1]\nOriginal message m:\n[1 -1 1 1 0 -1]\n</pre> In\u00a0[6]: Copied! <pre>import numpy as np\n</pre> import numpy as np In\u00a0[7]: Copied! <pre>L11 = pq.as_integer(np.identity(N))\nL12 = pq.as_integer([pq.polynomial.poly.pad(Rq.mul(pq.polynomial.poly.monomial(1, i), h), N - 1) for i in range(N)])\nL21 = pq.as_integer(np.zeros((N,N)))\nL22 = q * pq.as_integer(np.identity(N))\n\nNTRU_B = np.block([[L11, L12], [L21, L22]])\nprint(\"NTRU as lattice:\")\npq.show(NTRU_B, max_rows=14, max_cols=14)\n</pre> L11 = pq.as_integer(np.identity(N)) L12 = pq.as_integer([pq.polynomial.poly.pad(Rq.mul(pq.polynomial.poly.monomial(1, i), h), N - 1) for i in range(N)]) L21 = pq.as_integer(np.zeros((N,N))) L22 = q * pq.as_integer(np.identity(N))  NTRU_B = np.block([[L11, L12], [L21, L22]]) print(\"NTRU as lattice:\") pq.show(NTRU_B, max_rows=14, max_cols=14) <pre>NTRU as lattice:\nMatrix of integers with shape: 14 x 14\n======================================\n      [0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9]  [10]  [11]  [12]  [13]\n [0]    1    0    0    0    0    0    0   30   26    8    38     2    40    20\n [1]    0    1    0    0    0    0    0   20   30   26     8    38     2    40\n [2]    0    0    1    0    0    0    0   40   20   30    26     8    38     2\n [3]    0    0    0    1    0    0    0    2   40   20    30    26     8    38\n [4]    0    0    0    0    1    0    0   38    2   40    20    30    26     8\n [5]    0    0    0    0    0    1    0    8   38    2    40    20    30    26\n [6]    0    0    0    0    0    0    1   26    8   38     2    40    20    30\n [7]    0    0    0    0    0    0    0   41    0    0     0     0     0     0\n [8]    0    0    0    0    0    0    0    0   41    0     0     0     0     0\n [9]    0    0    0    0    0    0    0    0    0   41     0     0     0     0\n[10]    0    0    0    0    0    0    0    0    0    0    41     0     0     0\n[11]    0    0    0    0    0    0    0    0    0    0     0    41     0     0\n[12]    0    0    0    0    0    0    0    0    0    0     0     0    41     0\n[13]    0    0    0    0    0    0    0    0    0    0     0     0     0    41\n</pre> In\u00a0[8]: Copied! <pre>lll_B = pq.lattice.lll(NTRU_B)\nw = lll_B[1]\nprint(\"Short vector from LLL reduced basis:\")\nprint(w)\nf_prim = w[:N]\ng_prim = w[N:]\n\nf_prim_inv_q = Rq.inv(f_prim)\nf_prim_inv_p = Rp.inv(f_prim)\n\nprint(\"f'^-1 in Rq:\")\nprint(f_prim_inv_q)\nprint(\"f'^-1 * f':\", Rq.mul(f_prim_inv_q, f_prim))\nprint()\n\nprint(\"f'^-1 in Rp:\")\nprint(f_prim_inv_p)\nprint(\"f'^-1 * f':\", Rp.mul(f_prim_inv_p, f_prim))\nprint()\n</pre> lll_B = pq.lattice.lll(NTRU_B) w = lll_B[1] print(\"Short vector from LLL reduced basis:\") print(w) f_prim = w[:N] g_prim = w[N:]  f_prim_inv_q = Rq.inv(f_prim) f_prim_inv_p = Rp.inv(f_prim)  print(\"f'^-1 in Rq:\") print(f_prim_inv_q) print(\"f'^-1 * f':\", Rq.mul(f_prim_inv_q, f_prim)) print()  print(\"f'^-1 in Rp:\") print(f_prim_inv_p) print(\"f'^-1 * f':\", Rp.mul(f_prim_inv_p, f_prim)) print() <pre>Short vector from LLL reduced basis:\n[1 0 -1 1 0 -1 -1 -1 0 -1 0 1 1 0]\nf'^-1 in Rq:\n[20 10 15 33 4 39 1]\nf'^-1 * f': [1]\n\nf'^-1 in Rp:\n[2 0 1 2 2 2 2]\nf'^-1 * f': [1]\n\n</pre> In\u00a0[9]: Copied! <pre>a_prim = Rq.center_lift(Rq.mul(f_prim, e))\nd_prim = Rp.center_lift(Rp.mul(f_prim_inv_p, a_prim))\n\nprint(\"Decrypted message d:\")\nprint(d_prim)\nprint(\"Original message m:\")\nprint(m)\n</pre> a_prim = Rq.center_lift(Rq.mul(f_prim, e)) d_prim = Rp.center_lift(Rp.mul(f_prim_inv_p, a_prim))  print(\"Decrypted message d:\") print(d_prim) print(\"Original message m:\") print(m) <pre>Decrypted message d:\n[1 -1 1 1 0 -1]\nOriginal message m:\n[1 -1 1 1 0 -1]\n</pre>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#constructing-and-attacking-ntru-public-key-cryptosystem","title":"Constructing and attacking NTRU public key cryptosystem\u00b6","text":"<p>In contrast to cryptosystems such as RSA, Diffie-Hellman or ECC which are based on Group operations, the NTRU cryptosystem is a ring-based cryptosystem, specifically convolution polynomial rings, but it's underlying hard mathematical problem can also be interpreted as SVP or CVP in a lattice.</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#ntruencrypt","title":"NTRUEncrypt\u00b6","text":"<p>The NTRU public key cryptosystem, parameterized by integers $N$, $p$, $q$ and $d$ such that $$ \\begin{aligned} \\text{1.}&amp;\\; N \\in \\mathbb{P} \\; \\text{is prime} \\newline \\text{2.}&amp;\\; \\gcd(N,q) = \\gcd(p,q) = 1 \\newline \\text{3.}&amp;\\; d &gt; 0 \\newline \\text{4.}&amp;\\; q &gt; (6d + 1)p \\end{aligned} $$ is based on operations in three polynomial rings $R, R_p, R_q$ $$ R = \\frac{\\mathbb{Z}[X]}{X^{N} - 1}, \\quad R_p = \\frac{\\mathbb{Z}_p[X]}{X^{N} - 1}, \\quad R_q = \\frac{\\mathbb{Z}_q[X]}{X^{N} - 1} $$ and ternary polynomials defined for any positive integers $d_1$ and $d_2$ as $$ \\mathcal{T}(d_1, d_2) = \\left\\{ a(x) \\in R \\; \\middle| \\; \\begin{array}{l} a(x) \\; \\text{has} \\; d_1 \\; \\text{coefficients equal to 1,}\\newline a(x) \\; \\text{has} \\; d_2 \\; \\text{coefficients equal to -1,}\\newline a(x) \\; \\text{has all other coefficients equal to 0} \\end{array} \\right\\} $$</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#key-creation","title":"Key creation\u00b6","text":"<p>Let $(N, p, q, d)$ be publicly known parameters of the NTRU cryptosystem, chosen by some trusted authority. Private  key consists of two randomly chosen polynomials $$ f(x) \\in \\mathcal{T}(d + 1, d) \\qquad \\text{and} \\qquad g(x) \\in \\mathcal{T}(d, d) $$ To set up public key we first need to calculate inverses $$ F_q(x) = f(x)^{-1} \\; \\text{in} \\; R_q \\qquad \\text{and} \\qquad F_p = f(x)^{-1} \\; \\text{in} \\; R_p $$ The $f(x)$ must be chosen such that inverses $F_q(x)$ and $F_p(x)$ exists.</p> <p>The polynomial $h(x)$ defined as $$ h(x) = F_q(x) \\cdot g(x) \\; \\text{in} \\; R_q $$ will be a public key</p> <p>Private key: $(f(x), g(x))$ Public key: $h(x)$</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#encryption","title":"Encryption\u00b6","text":"<p>Plaintext $m$ has a form of polynomial $m(x) \\in R$ whose coefficients satisfy $ \\; -\\frac{1}{2}p &lt; m_i \\leq \\frac{1}{2}p $. In order to encrypt $m$ we also need a random polynomial $r(x) \\in \\mathcal{T}(d,d)$ then $$ e(x) \\equiv p h(x) \\cdot r(x) + m(x) \\quad \\mod q $$ is a ciphertext and $e(x) \\in R_q$</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#decryption","title":"Decryption\u00b6","text":"<p>To decrypt ciphertext $e(x)$ we first need to compute $$ a(x) \\equiv f(x) \\cdot e(x) \\quad \\mod q $$ then $$ b(x) \\equiv F_p(x) \\cdot \\text{center\\_lift} (a(x)) \\quad \\mod p $$ is equal to the plaintext $m(x)$</p>"},{"location":"examples/constructing_and_attacking_NTRU_pkc/#ntru-as-a-lattice","title":"NTRU as a lattice\u00b6","text":"<p>Given NTRU cryptosystem with parameters $(N,p,q,d)$ we are going to identify each pair of polynomials $$ a(x) = a_0 + \\ldots + a_{N-1}x^{N-1} \\qquad \\text{and} \\qquad b(x) = b_0 + \\ldots + b_{N-1}x^{N-1} $$ in $R$ with $2N$-dimensional vector $$ (a,b) = (a_0, \\ldots, a_{N-1}, b_0, \\ldots, b_{N-1}) \\in \\mathbb{Z}^{2N} $$</p>"},{"location":"examples/toy_kyber/","title":"Mini Kyber","text":"In\u00a0[1]: Copied! <pre>import pqlattice as pq\nimport numpy as np\n</pre> import pqlattice as pq import numpy as np In\u00a0[\u00a0]: Copied! <pre>!pip install pqlattice\n</pre> !pip install pqlattice In\u00a0[2]: Copied! <pre>n = 512\nm = 1024\nq = 3329\nsigma = 3.0\n\nsecret_dist = \"ternary\"\n</pre> n = 512 m = 1024 q = 3329 sigma = 3.0  secret_dist = \"ternary\" In\u00a0[3]: Copied! <pre>lwe = pq.random.LWE(n, q, sigma, secret_dist, 80)\nsecret = lwe.secret\nA, b = lwe.sample_matrix(m)\n\npublic_key = A, b\nsecret_key = secret\n</pre> lwe = pq.random.LWE(n, q, sigma, secret_dist, 80) secret = lwe.secret A, b = lwe.sample_matrix(m)  public_key = A, b secret_key = secret In\u00a0[6]: Copied! <pre>M = 1\nU = pq.random.distribution.Uniform(0, 1)\nr = U.sample_vector(m)\nu = pq.integer.mod(r @ public_key[0], q)\nvp = pq.integer.mod(np.dot(b, r), q)\nv = pq.integer.mod(vp + M * (q // 2), q)\n\nencrypted_msg = (u, v)\n</pre> M = 1 U = pq.random.distribution.Uniform(0, 1) r = U.sample_vector(m) u = pq.integer.mod(r @ public_key[0], q) vp = pq.integer.mod(np.dot(b, r), q) v = pq.integer.mod(vp + M * (q // 2), q)  encrypted_msg = (u, v) In\u00a0[7]: Copied! <pre>u, v = encrypted_msg\nnoisy_m = pq.integer.mod(v - np.dot(secret, u), q)\ndist_0 = min(noisy_m, q - noisy_m)\ndist_1 = abs(noisy_m - (q // 2))\n\nencrypted_msg = 0 if dist_0 &lt; dist_1 else 1\nprint(encrypted_msg)\n</pre> u, v = encrypted_msg noisy_m = pq.integer.mod(v - np.dot(secret, u), q) dist_0 = min(noisy_m, q - noisy_m) dist_1 = abs(noisy_m - (q // 2))  encrypted_msg = 0 if dist_0 &lt; dist_1 else 1 print(encrypted_msg) <pre>1\n</pre>"},{"location":"development/coverage/","title":"Coverage","text":""}]}